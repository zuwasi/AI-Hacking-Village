<?xml version='1.0' encoding='UTF-8' standalone='no'?><ResultsSession buildId="Default Project-2025-12-06" date="12/06/25 16:07:57" endTime="1970-01-01T02:00:00+02:00" machine="AI-logic-lab" project="Default Project" tag="SEI CERT C Guidelines" time="2025-12-06T16:07:57+02:00" toolName="C++test" toolVer="2025.1.0.20250523B2782" user="danie">
   <TestParameters cmdLn="C++test: -config c++test.builtin://SEI CERT C Guidelines "/>
   <TestConfig machine="AI-logic-lab" name="SEI CERT C Guidelines" pseudoUrl="c++test.builtin://SEI CERT C Guidelines" user="danie"/>
   <Authors>
      <Author id="dev1" name="danie"/>
   </Authors>
   <VersionInfos>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.execution" resultId="IExecutionViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.execution" resultId="InsureViolation" ver="3"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.scope" resultId="IScopeProjectInfo" ver="3"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IMetricsViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IDupCodeViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IFlowAnalysisViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="ICodingStandardsViolation" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.generation" resultId="IGenerationInfo" ver="2"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.generation" resultId="IGenerationProjectInfo" ver="2"/>
   </VersionInfos>
   
      <Locations>
               
         <Loc fsPath="C:\CERTC-AI-demo\src\ecu_sim.c" loc="/ecu_simulator/ecu_sim.c" projPath="/ecu_simulator" project="ecu_simulator"/>
            
      </Locations>
   
   
   <Scope>
      <ProjectInformations>
         <ScopeProjectInfo fltFiles="1" fltLns="253" project="/ecu_simulator" totFiles="1" totLns="253"/>
      </ProjectInformations>
   </Scope>
   <CodingStandards ownerId="com.parasoft.xtest.checkers.api.standards" time="0:00:20">
      <Projects>
         <Project bdCheckedFiles="1" bdTotalFiles="1" checkedFiles="1" checkedLns="253" name="ecu_simulator" qfixErrs="0" suppErrs="0" totErrs="212" totFiles="1" totLns="253"/>
      </Projects>
      <Rules>
         <RulesList>
            <Rule cat="CERT_C-API00" desc="The validity of parameters must be checked inside each function" id="CERT_C-API00-a" sev="3">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="CERT_C-API01" desc="Avoid overflow when writing to a buffer" id="CERT_C-API01-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-API01" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-API01-b" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-API02" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-API02-a" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-API02" desc="Don't use unsafe C functions that do write to range-unchecked buffers" id="CERT_C-API02-b" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="CERT_C-ARR01" desc="Do not call 'sizeof' on a pointer type" id="CERT_C-ARR01-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR02" desc="Explicitly specify array bounds in array declarations with initializers" id="CERT_C-ARR02-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR30" desc="Avoid accessing arrays out of bounds" id="CERT_C-ARR30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR32" desc="Ensure the size of the variable length array is in valid range" id="CERT_C-ARR32-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR36" desc="Do not subtract two pointers that do not address elements of the same array" id="CERT_C-ARR36-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR36" desc="Do not compare two unrelated pointers" id="CERT_C-ARR36-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR37" desc="Pointer arithmetic shall not be applied to pointers that address variables of non-array type" id="CERT_C-ARR37-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR38" desc="Avoid overflow when reading from a buffer" id="CERT_C-ARR38-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR38" desc="Avoid overflow when writing to a buffer" id="CERT_C-ARR38-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR38" desc="Avoid buffer overflow due to defining incorrect format limits" id="CERT_C-ARR38-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR38" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_C-ARR38-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR39" desc="Avoid accessing arrays out of bounds" id="CERT_C-ARR39-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR39" desc="Pointer arithmetic should not be used" id="CERT_C-ARR39-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ARR39" desc="Do not add or subtract a scaled integer to a pointer" id="CERT_C-ARR39-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON01" desc="Do not abandon unreleased locks" id="CERT_C-CON01-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON02" desc="Do not use the volatile keyword" id="CERT_C-CON02-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON05" desc="Do not use blocking functions while holding a lock" id="CERT_C-CON05-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON30" desc="Ensure resources are freed" id="CERT_C-CON30-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON31" desc="Do not destroy another thread's mutex" id="CERT_C-CON31-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON31" desc="Do not use resources that have been freed" id="CERT_C-CON31-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON31" desc="Do not free resources using invalid pointers" id="CERT_C-CON31-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON32" desc="Use locks to prevent race conditions when modifying bit fields" id="CERT_C-CON32-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON33" desc="Avoid using thread-unsafe functions" id="CERT_C-CON33-a" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="CERT_C-CON34" desc="Declare objects shared between POSIX threads with appropriate storage durations" id="CERT_C-CON34-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON35" desc="Do not acquire locks in different order" id="CERT_C-CON35-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON36" desc="Wrap functions that can spuriously wake up in a loop" id="CERT_C-CON36-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON37" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="CERT_C-CON37-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON38" desc="Use the 'cnd_signal()' function with a unique condition variable" id="CERT_C-CON38-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON39" desc="Do not join or detach a thread that was previously joined or detached" id="CERT_C-CON39-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON40" desc="Do not refer to an atomic variable twice in an expression" id="CERT_C-CON40-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON41" desc="Wrap functions that can fail spuriously in a loop" id="CERT_C-CON41-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-CON43" desc="Do not use global variable with different locks set" id="CERT_C-CON43-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL00" desc="Declare local variable as const whenever possible" id="CERT_C-DCL00-a" sev="3">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="CERT_C-DCL00" desc="Declare parameters as const whenever possible" id="CERT_C-DCL00-b" sev="3">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="CERT_C-DCL01" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="CERT_C-DCL01-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL01" desc="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="CERT_C-DCL01-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL02" desc="Use visually distinct identifiers" id="CERT_C-DCL02-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL04" desc="Each variable should be declared in a separate declaration statement" id="CERT_C-DCL04-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL05" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="CERT_C-DCL05-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL06" desc="Use meaningful symbolic constants to represent literal values" id="CERT_C-DCL06-a" sev="3">
               <Stats authTot="5;" total="5"/>
            </Rule>
            <Rule cat="CERT_C-DCL10" desc="The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal" id="CERT_C-DCL10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL11" desc="There should be no mismatch between the '%s' and '%c' format specifiers in the format string and their corresponding arguments in the invocation of a string formatting function" id="CERT_C-DCL11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL11" desc="There should be no mismatch between the '%f' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-DCL11-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL11" desc="There should be no mismatch between the '%i' and '%d' format specifiers in the string and their corresponding arguments in the invocation of a string formatting function" id="CERT_C-DCL11-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL11" desc="There should be no mismatch between the '%u' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-DCL11-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL11" desc="There should be no mismatch between the '%p' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-DCL11-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL11" desc="The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal" id="CERT_C-DCL11-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL12" desc="If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" id="CERT_C-DCL12-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL13" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="CERT_C-DCL13-a" sev="3">
               <Stats authTot="4;" total="4"/>
            </Rule>
            <Rule cat="CERT_C-DCL15" desc="Objects or functions with external linkage shall be declared in a header file" id="CERT_C-DCL15-a" sev="3">
               <Stats authTot="14;" total="14"/>
            </Rule>
            <Rule cat="CERT_C-DCL16" desc="The lowercase form of 'L' shall not be used as the first character in a literal suffix" id="CERT_C-DCL16-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL18" desc="Octal and hexadecimal escape sequences shall be terminated" id="CERT_C-DCL18-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL18" desc="Octal constants (other than zero) shall not be used" id="CERT_C-DCL18-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL19" desc="Declare variables as locally as possible" id="CERT_C-DCL19-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL20" desc="The number of arguments passed to a function shall match the number of parameters" id="CERT_C-DCL20-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL22" desc="Avoid unused values" id="CERT_C-DCL22-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL30" desc="The address of an object with automatic storage shall not be returned from a function" id="CERT_C-DCL30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL30" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="CERT_C-DCL30-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL31" desc="All functions shall be declared before use" id="CERT_C-DCL31-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL36" desc="Identifiers shall not simultaneously have both internal and external linkage in the same translation unit" id="CERT_C-DCL36-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL37" desc="Identifiers that begin with an underscore and either an uppercase letter or another underscore should not be declared" id="CERT_C-DCL37-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL37" desc="Avoid declaring file-scoped objects whose names begin with an underscore" id="CERT_C-DCL37-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL37" desc="The names of standard library macros should not be reused (C11 code)" id="CERT_C-DCL37-d" sev="3">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="CERT_C-DCL37" desc="The names of standard library identifiers with file scope should not be reused (C11 code)" id="CERT_C-DCL37-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL37" desc="The standard library identifiers with external linkage should not be reused (C11 code)" id="CERT_C-DCL37-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL37" desc="Macros that begin with an underscore and either an uppercase letter or another underscore should not be defined" id="CERT_C-DCL37-g" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL38" desc="The final member of a structure should not be an array of size '0' or '1'" id="CERT_C-DCL38-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL39" desc="A pointer to a structure should not be passed to a function that can copy data to the user space" id="CERT_C-DCL39-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL40" desc="All declarations of an object or function shall have compatible types" id="CERT_C-DCL40-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL40" desc="If objects or functions are declared more than once their types shall be compatible" id="CERT_C-DCL40-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-DCL41" desc="A switch statement shall only contain switch labels and switch clauses, and no other code" id="CERT_C-DCL41-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV01" desc="Don't use unsafe C functions that do write to range-unchecked buffers" id="CERT_C-ENV01-a" sev="1">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="CERT_C-ENV01" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-ENV01-b" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-ENV01" desc="Avoid overflow when writing to a buffer" id="CERT_C-ENV01-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV02" desc="Usage of system properties (environment variables) should be restricted" id="CERT_C-ENV02-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV30" desc="The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type" id="CERT_C-ENV30-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV31" desc="Do not rely on an environment pointer following an operation that may invalidate it" id="CERT_C-ENV31-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV32" desc="Properly define exit handlers" id="CERT_C-ENV32-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV33" desc="The 'system()' function from the 'stdlib.h' or 'cstdlib' library should not be used with an argument other than '0' (null pointer)" id="CERT_C-ENV33-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ENV34" desc="Pointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function" id="CERT_C-ENV34-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR01" desc="The error indicator 'errno' shall not be used" id="CERT_C-ERR01-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR02" desc="The input/output functions from the 'cstdio' and 'cwchar' libraries should not be used" id="CERT_C-ERR02-a" sev="3">
               <Stats authTot="16;" total="16"/>
            </Rule>
            <Rule cat="CERT_C-ERR04" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR04-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR04" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR04-b" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-ERR04" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR04-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR05" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR05-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR05" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR05-b" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-ERR05" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR05-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR06" desc="Do not use assertions" id="CERT_C-ERR06-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR07" desc="The 'atof', 'atoi', 'atol' and 'atoll' functions from the 'stdlib.h' or 'cstdlib' library should not be used" id="CERT_C-ERR07-a" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-ERR07" desc="The library functions 'rewind', 'setbuf' and 'ctime' should not be used" id="CERT_C-ERR07-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR30" desc="Properly use errno value" id="CERT_C-ERR30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR32" desc="Properly define signal handlers" id="CERT_C-ERR32-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR33" desc="The value returned by a standard library function that may return an error should be used" id="CERT_C-ERR33-a" sev="1">
               <Stats authTot="14;" total="14"/>
            </Rule>
            <Rule cat="CERT_C-ERR33" desc="Always check the returned value of non-void function" id="CERT_C-ERR33-d" sev="1">
               <Stats authTot="15;" total="15"/>
            </Rule>
            <Rule cat="CERT_C-ERR33" desc="Provide error handling for file opening errors right next to the call to fopen" id="CERT_C-ERR33-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-ERR34" desc="The 'atof', 'atoi', 'atol' and 'atoll' functions from the 'stdlib.h' or 'cstdlib' library should not be used" id="CERT_C-ERR34-a" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-EXP00" desc="Use parenthesis to clarify expression order if operators with precedence lower than arithmetic are used" id="CERT_C-EXP00-a" sev="3">
               <Stats authTot="6;" total="6"/>
            </Rule>
            <Rule cat="CERT_C-EXP02" desc="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="CERT_C-EXP02-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP05" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="CERT_C-EXP05-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP08" desc="Pointer arithmetic should not be used" id="CERT_C-EXP08-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP08" desc="Avoid accessing arrays out of bounds" id="CERT_C-EXP08-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP10" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="CERT_C-EXP10-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP10" desc="Avoid code that depends on the order of evaluation of function arguments" id="CERT_C-EXP10-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP10" desc="Avoid code that depends on the order of evaluation of the function designator and function arguments" id="CERT_C-EXP10-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP10" desc="Avoid code that depends on the order of evaluation of expressions involving a function call" id="CERT_C-EXP10-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP12" desc="The value returned by a function having non-void return type shall be used" id="CERT_C-EXP12-a" sev="3">
               <Stats authTot="35;" total="35"/>
            </Rule>
            <Rule cat="CERT_C-EXP12" desc="The value returned by a function having non-void return type shall be used" id="CERT_C-EXP12-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP14" desc="Avoid mixing arithmetic of different precisions in the same expression" id="CERT_C-EXP14-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP15" desc="Suspicious use of semicolon" id="CERT_C-EXP15-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP16" desc="Function address should not be compared to zero" id="CERT_C-EXP16-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP19" desc="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="CERT_C-EXP19-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP20" desc="Avoid comparing values with the 'TRUE' identifier using equality operators (&quot;==&quot;, &quot;!=&quot;)" id="CERT_C-EXP20-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP20" desc="Tests of a value against zero should be made explicit, unless the operand is effectively Boolean" id="CERT_C-EXP20-b" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-EXP30" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="CERT_C-EXP30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP30" desc="Avoid code that depends on the order of evaluation of function arguments" id="CERT_C-EXP30-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP30" desc="Avoid code that depends on the order of evaluation of the function designator and function arguments" id="CERT_C-EXP30-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP30" desc="Avoid code that depends on the order of evaluation of expressions involving a function call" id="CERT_C-EXP30-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP32" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="CERT_C-EXP32-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP33" desc="Avoid use before initialization" id="CERT_C-EXP33-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP34" desc="Avoid null pointer dereferencing" id="CERT_C-EXP34-a" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-EXP35" desc="Do not modify objects with temporary lifetime" id="CERT_C-EXP35-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP36" desc="Do not cast pointers into more strictly aligned pointer types" id="CERT_C-EXP36-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP37" desc="Conversions shall not be performed between non compatible pointer to a function types" id="CERT_C-EXP37-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP37" desc="Specify the access permission bits if a file is created using the 'open' or 'openat' system call" id="CERT_C-EXP37-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP37" desc="Functions shall always have visible prototype at the function call" id="CERT_C-EXP37-d" sev="3">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="CERT_C-EXP39" desc="There shall be no implicit conversions from integral to floating type" id="CERT_C-EXP39-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP39" desc="A cast should not be performed between a pointer to object type and a different pointer to object type" id="CERT_C-EXP39-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP39" desc="Avoid accessing arrays and pointers out of bounds" id="CERT_C-EXP39-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP39" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="CERT_C-EXP39-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP39" desc="Avoid buffer read overflow from tainted data" id="CERT_C-EXP39-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP39" desc="Avoid buffer write overflow from tainted data" id="CERT_C-EXP39-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP40" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="CERT_C-EXP40-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP42" desc="Don't memcpy or memcmp non-PODs" id="CERT_C-EXP42-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP43" desc="The restrict type qualifier shall not be used" id="CERT_C-EXP43-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP44" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="CERT_C-EXP44-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP44" desc="The function call that causes the side effect shall not be the operand of the sizeof operator" id="CERT_C-EXP44-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP45" desc="Assignment operators shall not be used in conditions without brackets" id="CERT_C-EXP45-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP45" desc="Assignment operators shall not be used in expressions that yield a Boolean value" id="CERT_C-EXP45-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP46" desc="Expressions that are effectively Boolean should not be used as operands to operators other than (&amp;&amp;, ||, !, =, ==, !=, ?:)" id="CERT_C-EXP46-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-EXP47" desc="Do not call va_arg with an argument of the incorrect type" id="CERT_C-EXP47-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO01" desc="Don't use chmod(), chown(), chgrp()" id="CERT_C-FIO01-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO01" desc="Be careful using functions that use file names for identification" id="CERT_C-FIO01-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO21" desc="Use secure temporary file name functions" id="CERT_C-FIO21-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO22" desc="Ensure resources are freed" id="CERT_C-FIO22-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO24" desc="Avoid race conditions while accessing files" id="CERT_C-FIO24-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO30" desc="Avoid calling functions printf/wprintf with only one argument other than string constant" id="CERT_C-FIO30-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO30" desc="Avoid using functions fprintf/fwprintf with only two parameters, when second parameter is a variable" id="CERT_C-FIO30-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO30" desc="Never use unfiltered data from an untrusted user as the format parameter" id="CERT_C-FIO30-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO32" desc="Protect against file name injection" id="CERT_C-FIO32-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO34" desc="The macro EOF should be compared with the unmodified return value from the Standard Library function" id="CERT_C-FIO34-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO37" desc="Avoid accessing arrays out of bounds" id="CERT_C-FIO37-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO38" desc="A pointer to a FILE object shall not be dereferenced" id="CERT_C-FIO38-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO39" desc="Do not alternately input and output from a stream without an intervening flush or positioning call" id="CERT_C-FIO39-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO40" desc="Reset strings on fgets() or fgetws() failure" id="CERT_C-FIO40-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO41" desc="Do not call 'getc()', 'putc()', 'getwc()', or 'putwc()' with a stream argument containing assignments, increment or decrement operators" id="CERT_C-FIO41-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO41" desc="Do not call 'getc()', 'putc()', 'getwc()', or 'putwc()' with a stream argument containing function calls or function-like macro calls" id="CERT_C-FIO41-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO42" desc="Ensure resources are freed" id="CERT_C-FIO42-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO44" desc="Only use values for fsetpos() that are returned from fgetpos()" id="CERT_C-FIO44-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO45" desc="Avoid race conditions while accessing files" id="CERT_C-FIO45-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO46" desc="Do not use resources that have been freed" id="CERT_C-FIO46-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO47" desc="There should be no mismatch between the '%s' and '%c' format specifiers in the format string and their corresponding arguments in the invocation of a string formatting function" id="CERT_C-FIO47-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO47" desc="There should be no mismatch between the '%f' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-FIO47-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO47" desc="There should be no mismatch between the '%i' and '%d' format specifiers in the string and their corresponding arguments in the invocation of a string formatting function" id="CERT_C-FIO47-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO47" desc="There should be no mismatch between the '%u' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-FIO47-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO47" desc="There should be no mismatch between the '%p' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-FIO47-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FIO47" desc="The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal" id="CERT_C-FIO47-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP00" desc="Floating-point expressions shall not be tested for equality or inequality" id="CERT_C-FLP00-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP02" desc="Floating-point expressions shall not be tested for equality or inequality" id="CERT_C-FLP02-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP03" desc="Avoid division by zero" id="CERT_C-FLP03-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP03" desc="Avoid implicit conversions from wider to narrower floating type" id="CERT_C-FLP03-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP03" desc="Avoid implicit conversions from narrower to wider floating type" id="CERT_C-FLP03-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP03" desc="Avoid implicit conversions of floating point numbers from wider to narrower floating type" id="CERT_C-FLP03-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP06" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="CERT_C-FLP06-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP06" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="CERT_C-FLP06-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP30" desc="Do not use floating point variables as loop counters" id="CERT_C-FLP30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP32" desc="Validate values passed to library functions" id="CERT_C-FLP32-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP34" desc="Avoid implicit conversions from wider to narrower floating type" id="CERT_C-FLP34-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP34" desc="Avoid implicit conversions of floating point numbers from wider to narrower floating type" id="CERT_C-FLP34-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP36" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="CERT_C-FLP36-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP36" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="CERT_C-FLP36-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-FLP37" desc="Do not use object representations to compare floating-point values" id="CERT_C-FLP37-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT02" desc="Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used" id="CERT_C-INT02-a" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-INT02" desc="Avoid mixing arithmetic of different precisions in the same expression" id="CERT_C-INT02-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT04" desc="Avoid potential integer overflow/underflow on tainted data" id="CERT_C-INT04-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT04" desc="Avoid buffer read overflow from tainted data" id="CERT_C-INT04-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT04" desc="Avoid buffer write overflow from tainted data" id="CERT_C-INT04-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT05" desc="Avoid using unsafe string functions that do not check bounds" id="CERT_C-INT05-a" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="CERT_C-INT07" desc="The plain char type shall be used only for the storage and use of character values" id="CERT_C-INT07-a" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-INT07" desc="signed and unsigned char type shall be used only for the storage and use of numeric values" id="CERT_C-INT07-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT08" desc="Avoid data loss when converting between integer types" id="CERT_C-INT08-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT08" desc="Avoid signed integer overflows" id="CERT_C-INT08-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT08" desc="Avoid value change when converting between integer types" id="CERT_C-INT08-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT08" desc="Avoid wraparounds when performing arithmetic integer operations" id="CERT_C-INT08-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT09" desc="In an enumerator list, the &quot;=&quot; construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised" id="CERT_C-INT09-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT10" desc="The operands of the remainder operator '%' should be of unsigned integer types" id="CERT_C-INT10-a" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-INT12" desc="Bit fields shall only be defined to be of type unsigned int or signed int" id="CERT_C-INT12-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT13" desc="Operands of bitwise and complement operators shall have an unsigned type" id="CERT_C-INT13-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT13" desc="Operands of shift operators shall have an unsigned type" id="CERT_C-INT13-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT15" desc="Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types" id="CERT_C-INT15-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT16" desc="Bitwise operators shall only be applied to operands of unsigned underlying type (with exceptions)" id="CERT_C-INT16-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT16" desc="Bitwise operators shall not use positive integer literals as operands" id="CERT_C-INT16-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT18" desc="Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type" id="CERT_C-INT18-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT18" desc="Avoid possible integer overflow in expressions in which the result is compared to an expression of a wider integer type" id="CERT_C-INT18-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT18" desc="Avoid possible integer overflow in expressions in which the result is cast to a wider integer type" id="CERT_C-INT18-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT30" desc="Avoid wraparounds when performing arithmetic integer operations" id="CERT_C-INT30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT30" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="CERT_C-INT30-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT30" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="CERT_C-INT30-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" id="CERT_C-INT31-a" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value" id="CERT_C-INT31-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="An operand of essentially character type should not be used where an operand is interpreted as a numeric value" id="CERT_C-INT31-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="An operand of essentially enum type should not be used in an arithmetic operation" id="CERT_C-INT31-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="Shift and bitwise operations should not be performed on operands of essentially signed or enum type" id="CERT_C-INT31-e" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="An operand of essentially signed or enum type should not be used as the right hand operand to the bitwise shifting operator" id="CERT_C-INT31-f" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="An operand of essentially unsigned type should not be used as the operand to the unary minus operator" id="CERT_C-INT31-g" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="The value of an expression shall not be assigned to an object with a narrower essential type" id="CERT_C-INT31-h" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="The value of an expression shall not be assigned to an object of a different essential type category" id="CERT_C-INT31-i" sev="2">
               <Stats authTot="3;" total="3"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" id="CERT_C-INT31-j" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="The second and third operands of the ternary operator shall have the same essential type category" id="CERT_C-INT31-k" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="The value of a composite expression shall not be assigned to an object with wider essential type" id="CERT_C-INT31-l" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" id="CERT_C-INT31-m" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type" id="CERT_C-INT31-n" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="Avoid data loss when converting between integer types" id="CERT_C-INT31-o" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT31" desc="Avoid value change when converting between integer types" id="CERT_C-INT31-p" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT32" desc="Avoid signed integer overflows" id="CERT_C-INT32-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT32" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="CERT_C-INT32-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT32" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="CERT_C-INT32-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT33" desc="Avoid division by zero" id="CERT_C-INT33-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT34" desc="Avoid incorrect shift operations" id="CERT_C-INT34-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT35" desc="Use correct integer precisions when checking the right hand operand of the shift operator" id="CERT_C-INT35-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-INT36" desc="A conversion should not be performed between a pointer to object type and an integer type other than 'uintptr_t' or 'intptr_t'" id="CERT_C-INT36-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM00" desc="Do not allocate memory and expect that someone else will deallocate it later" id="CERT_C-MEM00-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM00" desc="Do not allocate memory and expect that someone else will deallocate it later" id="CERT_C-MEM00-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM00" desc="Do not allocate memory and expect that someone else will deallocate it later" id="CERT_C-MEM00-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM00" desc="Do not use resources that have been freed" id="CERT_C-MEM00-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM00" desc="Ensure resources are freed" id="CERT_C-MEM00-e" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM01" desc="Do not use resources that have been freed" id="CERT_C-MEM01-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM01" desc="Always assign a new value to an expression that points to deallocated memory" id="CERT_C-MEM01-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM01" desc="Always assign a new value to global or member variable that points to deallocated memory" id="CERT_C-MEM01-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM01" desc="Always assign a new value to parameter or local variable that points to deallocated memory" id="CERT_C-MEM01-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM02" desc="The result of the memory allocation function should be cast immediately" id="CERT_C-MEM02-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM02" desc="The result of the memory allocation function should be cast immediately into a pointer to the allocated type" id="CERT_C-MEM02-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM03" desc="Sensitive data should be cleared before being deallocated" id="CERT_C-MEM03-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM04" desc="The validity of values passed to library functions shall be checked" id="CERT_C-MEM04-a" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="CERT_C-MEM05" desc="Do not use recursion" id="CERT_C-MEM05-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM05" desc="Ensure the size of the variable length array is in valid range" id="CERT_C-MEM05-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM07" desc="The validity of values passed to library functions shall be checked" id="CERT_C-MEM07-a" sev="2">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="CERT_C-MEM12" desc="Ensure resources are freed" id="CERT_C-MEM12-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM30" desc="Do not use resources that have been freed" id="CERT_C-MEM30-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM31" desc="Ensure resources are freed" id="CERT_C-MEM31-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM33" desc="Allocate structures containing a flexible array member dynamically" id="CERT_C-MEM33-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM33" desc="Do not copy instances of structures containing a flexible array member" id="CERT_C-MEM33-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM34" desc="Do not free resources using invalid pointers" id="CERT_C-MEM34-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM35" desc="Do not use sizeof operator on pointer type to specify the size of the memory to be allocated via 'malloc', 'calloc' or 'realloc' function" id="CERT_C-MEM35-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MEM36" desc="Do not modify the alignment of objects by calling realloc()" id="CERT_C-MEM36-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC01" desc="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="CERT_C-MSC01-a" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-MSC01" desc="The final clause of a switch statement shall be the default clause" id="CERT_C-MSC01-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC04" desc="The character sequence /* shall not be used within a C-style comment" id="CERT_C-MSC04-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC04" desc="The character sequence // shall not be used within a C-style comment" id="CERT_C-MSC04-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC04" desc="The character sequence /* shall not be used within a C++-style comment" id="CERT_C-MSC04-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC04" desc="Line-splicing shall not be used in // comments" id="CERT_C-MSC04-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC06" desc="Avoid calls to memory-setting functions that can be optimized out by the compiler" id="CERT_C-MSC06-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code in &quot;else&quot; block" id="CERT_C-MSC07-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="CERT_C-MSC07-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="CERT_C-MSC07-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code in switch statement" id="CERT_C-MSC07-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code in 'for' loop" id="CERT_C-MSC07-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="CERT_C-MSC07-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="CERT_C-MSC07-g" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="Avoid switch with unreachable branches" id="CERT_C-MSC07-h" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC07" desc="Avoid unreachable methods" id="CERT_C-MSC07-i" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC09" desc="Only use characters defined in the ISO C standard" id="CERT_C-MSC09-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC11" desc="Assert liberally to document internal assumptions and invariants" id="CERT_C-MSC11-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code in &quot;else&quot; block" id="CERT_C-MSC12-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="CERT_C-MSC12-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="CERT_C-MSC12-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code in switch statement" id="CERT_C-MSC12-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code in 'for' loop" id="CERT_C-MSC12-e" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="CERT_C-MSC12-f" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="CERT_C-MSC12-g" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="Avoid switch with unreachable branches" id="CERT_C-MSC12-h" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="Avoid unreachable methods" id="CERT_C-MSC12-i" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="Avoid conditions that always evaluate to the same value" id="CERT_C-MSC12-j" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC12" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="CERT_C-MSC12-k" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC13" desc="Avoid unnecessary local variables" id="CERT_C-MSC13-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC14" desc="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="CERT_C-MSC14-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC14" desc="Evaluation of constant unsigned integer expressions in preprocessor directives should not lead to wraparound" id="CERT_C-MSC14-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC15" desc="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="CERT_C-MSC15-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC15" desc="Evaluation of constant unsigned integer expressions in preprocessor directives should not lead to wraparound" id="CERT_C-MSC15-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC17" desc="Missing break statement between cases in a switch statement" id="CERT_C-MSC17-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC19" desc="Avoid accessing arrays out of bounds" id="CERT_C-MSC19-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC19" desc="Avoid null pointer dereferencing" id="CERT_C-MSC19-b" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-MSC22" desc="The facilities provided by &lt;setjmp.h> should not be used" id="CERT_C-MSC22-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC24" desc="The 'atof', 'atoi', 'atol' and 'atoll' functions from the 'stdlib.h' or 'cstdlib' library should not be used" id="CERT_C-MSC24-a" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-MSC24" desc="The 'getenv()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-MSC24-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC24" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-MSC24-c" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-MSC24" desc="Don't use unsafe C functions that do write to range-unchecked buffers" id="CERT_C-MSC24-d" sev="3">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="CERT_C-MSC30" desc="Do not use the rand() function for generating pseudorandom numbers" id="CERT_C-MSC30-a" sev="2">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-MSC32" desc="Properly seed pseudorandom number generators" id="CERT_C-MSC32-d" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-MSC33" desc="The 'asctime()' and 'asctime_r()' functions should not be used" id="CERT_C-MSC33-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC37" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="CERT_C-MSC37-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC38" desc="A function-like macro shall not be invoked without all of its arguments" id="CERT_C-MSC38-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC39" desc="Use macros for variable arguments correctly" id="CERT_C-MSC39-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC40" desc="An inline definition of a function with external linkage shall not contain definitions and uses of static objects" id="CERT_C-MSC40-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-MSC41" desc="Do not hard code string literals" id="CERT_C-MSC41-a" sev="1">
               <Stats authTot="29;" total="29"/>
            </Rule>
            <Rule cat="CERT_C-POS30" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_C-POS30-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS30" desc="The values returned by functions 'read' and 'readlink' shall be used" id="CERT_C-POS30-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS30" desc="Use of possibly not null-terminated string with functions expecting null-terminated string" id="CERT_C-POS30-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS33" desc="Avoid using the 'vfork()' function" id="CERT_C-POS33-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS34" desc="Usage of system properties (environment variables) should be restricted" id="CERT_C-POS34-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS34" desc="Do not call putenv() with a pointer to an automatic variable as the argument" id="CERT_C-POS34-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS35" desc="Avoid race conditions while checking for the existence of a symbolic link" id="CERT_C-POS35-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS36" desc="Observe correct revocation order while relinquishing privileges" id="CERT_C-POS36-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS37" desc="Ensure that privilege relinquishment is successful" id="CERT_C-POS37-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS38" desc="Avoid race conditions when using fork and file descriptors" id="CERT_C-POS38-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS39" desc="Use the correct byte ordering when transferring data between systems" id="CERT_C-POS39-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS44" desc="The 'pthread_kill', 'pthread_sigqueue' and 'tgkill' functions should not be used to send signals to threads" id="CERT_C-POS44-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS47" desc="The function 'pthread_setcanceltype()' should not be called with 'PTHREAD_CANCEL_ASYNCHRONOUS' argument" id="CERT_C-POS47-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS48" desc="Do not destroy another thread's mutex" id="CERT_C-POS48-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS48" desc="Do not release a lock that has not been acquired" id="CERT_C-POS48-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS49" desc="Use locks to prevent race conditions when modifying bit fields" id="CERT_C-POS49-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS50" desc="Declare objects shared between POSIX threads with appropriate storage durations" id="CERT_C-POS50-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS51" desc="Do not acquire locks in different order" id="CERT_C-POS51-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS52" desc="Do not use blocking functions while holding a lock" id="CERT_C-POS52-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS53" desc="Do not use more than one mutex for concurrent waiting operations on a condition variable" id="CERT_C-POS53-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-POS54" desc="The value returned by a POSIX library function that may return an error should be used" id="CERT_C-POS54-a" sev="1">
               <Stats authTot="15;" total="15"/>
            </Rule>
            <Rule cat="CERT_C-PRE00" desc="A function should be used in preference to a function-like macro" id="CERT_C-PRE00-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE01" desc="In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##" id="CERT_C-PRE01-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE02" desc="Enclose the entire definition of a function-like macro in parentheses" id="CERT_C-PRE02-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE06" desc="Use multiple include guards" id="CERT_C-PRE06-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE07" desc="Trigraphs shall not be used" id="CERT_C-PRE07-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE30" desc="Avoid token concatenation that may produce universal character names" id="CERT_C-PRE30-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE31" desc="Assertions should not contain assignments, increment, or decrement operators" id="CERT_C-PRE31-b" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE31" desc="Assertions should not contain function calls nor function-like macro calls" id="CERT_C-PRE31-c" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE31" desc="Avoid side effects in arguments to unsafe macros" id="CERT_C-PRE31-d" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-PRE32" desc="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="CERT_C-PRE32-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG00" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="CERT_C-SIG00-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG01" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="CERT_C-SIG01-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG02" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="CERT_C-SIG02-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG30" desc="Properly define signal handlers" id="CERT_C-SIG30-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG31" desc="Properly define signal handlers" id="CERT_C-SIG31-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG34" desc="Properly define signal handlers" id="CERT_C-SIG34-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-SIG35" desc="Do not return from a computational exception signal handler" id="CERT_C-SIG35-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR00" desc="The plain char type shall be used only for the storage and use of character values" id="CERT_C-STR00-a" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-STR02" desc="Protect against command injection" id="CERT_C-STR02-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR02" desc="Protect against file name injection" id="CERT_C-STR02-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR02" desc="Protect against SQL injection" id="CERT_C-STR02-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR03" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_C-STR03-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR04" desc="The plain char type shall be used only for the storage and use of character values" id="CERT_C-STR04-a" sev="3">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-STR05" desc="A string literal shall not be modified" id="CERT_C-STR05-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR07" desc="Avoid using unsafe string functions that do not check bounds" id="CERT_C-STR07-a" sev="1">
               <Stats authTot="2;" total="2"/>
            </Rule>
            <Rule cat="CERT_C-STR09" desc="Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than  =,  ==, != and the unary &amp; operator" id="CERT_C-STR09-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR10" desc="Narrow and wide string literals shall not be concatenated" id="CERT_C-STR10-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR11" desc="Do not specify the bound of a character array initialized with a string literal" id="CERT_C-STR11-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR30" desc="A string literal shall not be modified" id="CERT_C-STR30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR30" desc="Do not modify string literals" id="CERT_C-STR30-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR31" desc="Avoid accessing arrays out of bounds" id="CERT_C-STR31-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR31" desc="Avoid overflow when writing to a buffer" id="CERT_C-STR31-b" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR31" desc="Prevent buffer overflows from tainted data" id="CERT_C-STR31-c" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR31" desc="Avoid buffer write overflow from tainted data" id="CERT_C-STR31-d" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR31" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-STR31-e" sev="1">
               <Stats authTot="1;" total="1"/>
            </Rule>
            <Rule cat="CERT_C-STR32" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_C-STR32-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR34" desc="Cast characters to unsigned char before assignment to larger integer sizes" id="CERT_C-STR34-b" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR34" desc="An expressions of the 'signed char' type should not be used as an array index" id="CERT_C-STR34-c" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR34" desc="Cast characters to unsigned char before converting to larger integer sizes" id="CERT_C-STR34-d" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR37" desc="Do not pass incorrect values to ctype.h library functions" id="CERT_C-STR37-a" sev="3">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-STR38" desc="Do not confuse narrow and wide character strings and functions" id="CERT_C-STR38-a" sev="1">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-WIN00" desc="Use care to ensure that LoadLibrary() will load the correct library" id="CERT_C-WIN00-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
            <Rule cat="CERT_C-WIN30" desc="Ensure resources are freed" id="CERT_C-WIN30-a" sev="2">
               <Stats authTot="0;" total="0"/>
            </Rule>
         </RulesList>
         <CategoriesList>
            <Category desc="SEI CERT C" name="CERT_C" total="374">
               <Category desc="CERT-MSC12_C (REC) Detect and remove code that has no effect or is never executed" name="CERT_C-MSC12" total="11">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC11_C (REC) Incorporate diagnostic tests using assertions" name="CERT_C-MSC11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC14_C (REC) Do not introduce unnecessary platform dependencies" name="CERT_C-MSC14" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC13_C (REC) Detect and remove unused values" name="CERT_C-MSC13" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC15_C (REC) Do not depend on undefined behavior" name="CERT_C-MSC15" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-WIN00_C (REC) Be specific when dynamically loading libraries" name="CERT_C-WIN00" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP03_C (REC) Detect and handle floating-point errors" name="CERT_C-FLP03" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC17_C (REC) Finish every set of statements associated with a case label with a break statement" name="CERT_C-MSC17" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP02_C (REC) Avoid using floating-point numbers when precise computation is needed" name="CERT_C-FLP02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC19_C (REC) For functions that return an array, prefer returning an empty array over a null value" name="CERT_C-MSC19" total="2">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-FLP06_C (REC) Convert integers to floating point for floating-point operations" name="CERT_C-FLP06" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT02_C (REC) Understand integer conversion rules" name="CERT_C-INT02" total="2">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-FLP00_C (REC) Understand the limitations of floating-point numbers" name="CERT_C-FLP00" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-API01_C (REC) Avoid laying out strings in memory directly before sensitive data" name="CERT_C-API01" total="2">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-API02_C (REC) Functions that read or write to or from an array should take an argument to specify the source or target size" name="CERT_C-API02" total="2">
                  <Stats authTot="3;" total="3"/>
               </Category>
               <Category desc="CERT-INT08_C (REC) Verify that all integer values are in range" name="CERT_C-INT08" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT09_C (REC) Ensure enumeration constants map to unique values" name="CERT_C-INT09" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT07_C (REC) Use only explicitly signed or unsigned char type for numeric values" name="CERT_C-INT07" total="2">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-INT04_C (REC) Enforce limits on integer values originating from tainted sources" name="CERT_C-INT04" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT05_C (REC) Do not use input functions to convert character data if they cannot handle all possible inputs" name="CERT_C-INT05" total="1">
                  <Stats authTot="2;" total="2"/>
               </Category>
               <Category desc="CERT-ENV30_C (RULE) Do not modify the object referenced by the return value of certain functions" name="CERT_C-ENV30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC22_C (REC) Use the setjmp(), longjmp() facility securely" name="CERT_C-MSC22" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC24_C (REC) Do not use deprecated or obsolescent functions" name="CERT_C-MSC24" total="4">
                  <Stats authTot="4;" total="4"/>
               </Category>
               <Category desc="CERT-INT13_C (REC) Use bitwise operators only on unsigned operands" name="CERT_C-INT13" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT12_C (REC) Do not make assumptions about the type of a plain int bit-field when used in an expression" name="CERT_C-INT12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT10_C (REC) Do not assume a positive remainder when using the % operator" name="CERT_C-INT10" total="1">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-ENV33_C (RULE) Do not call system()" name="CERT_C-ENV33" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ENV34_C (RULE) Do not store pointers returned by certain functions" name="CERT_C-ENV34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT18_C (REC) Evaluate integer expressions in a larger size before comparing or assigning to that size" name="CERT_C-INT18" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ENV31_C (RULE) Do not rely on an environment pointer following an operation that may invalidate it" name="CERT_C-ENV31" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT15_C (REC) Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types" name="CERT_C-INT15" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC30_C (RULE) Do not use the rand() function for generating pseudorandom numbers" name="CERT_C-MSC30" total="1">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-ENV32_C (RULE) All exit handlers must return normally" name="CERT_C-ENV32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT16_C (REC) Do not make assumptions about representation of signed integers" name="CERT_C-INT16" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM00_C (REC) Allocate and free memory in the same module, at the same level of abstraction" name="CERT_C-MEM00" total="5">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM01_C (REC) Store a new value in pointers immediately after free()" name="CERT_C-MEM01" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG30_C (RULE) Call only asynchronous-safe functions within signal handlers" name="CERT_C-SIG30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM04_C (REC) Beware of zero-length allocations" name="CERT_C-MEM04" total="1">
                  <Stats authTot="2;" total="2"/>
               </Category>
               <Category desc="CERT-MEM05_C (REC) Avoid large stack allocations" name="CERT_C-MEM05" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG31_C (RULE) Do not access shared objects in signal handlers" name="CERT_C-SIG31" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM02_C (REC) Immediately cast the result of a memory allocation function call into a pointer to the allocated type" name="CERT_C-MEM02" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG34_C (RULE) Do not call signal() from within interruptible signal handlers" name="CERT_C-SIG34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM03_C (REC) Clear sensitive information stored in reusable resources" name="CERT_C-MEM03" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG35_C (RULE) Do not return from a computational exception signal handler" name="CERT_C-SIG35" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE31_C (RULE) Avoid side effects in arguments to unsafe macros" name="CERT_C-PRE31" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE32_C (RULE) Do not use preprocessor directives in invocations of function-like macros" name="CERT_C-PRE32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE30_C (RULE) Do not create a universal character name through concatenation" name="CERT_C-PRE30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ENV02_C (REC) Beware of multiple environment variables with the same effective name" name="CERT_C-ENV02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ENV01_C (REC) Do not make assumptions about the size of an environment variable" name="CERT_C-ENV01" total="3">
                  <Stats authTot="3;" total="3"/>
               </Category>
               <Category desc="CERT-MSC01_C (REC) Strive for logical completeness" name="CERT_C-MSC01" total="2">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-MSC04_C (REC) Use comments consistently and in a readable fashion" name="CERT_C-MSC04" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC07_C (REC) Detect and remove dead code" name="CERT_C-MSC07" total="9">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC06_C (REC) Beware of compiler optimizations" name="CERT_C-MSC06" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC09_C (REC) Character encoding: Use subset of ASCII for safety" name="CERT_C-MSC09" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT35_C (RULE) Use correct integer precisions" name="CERT_C-INT35" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT36_C (RULE) Converting a pointer to integer or integer to pointer" name="CERT_C-INT36" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT33_C (RULE) Ensure that division and remainder operations do not result in divide-by-zero errors" name="CERT_C-INT33" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT34_C (RULE) Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand" name="CERT_C-INT34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT31_C (RULE) Ensure that integer conversions do not result in lost or misinterpreted data" name="CERT_C-INT31" total="16">
                  <Stats authTot="6;" total="6"/>
               </Category>
               <Category desc="CERT-INT32_C (RULE) Ensure that operations on signed integers do not result in overflow" name="CERT_C-INT32" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-INT30_C (RULE) Ensure that unsigned integer operations do not wrap" name="CERT_C-INT30" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO34_C (RULE) Distinguish between characters read from a file and EOF or WEOF" name="CERT_C-FIO34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO32_C (RULE) Do not perform operations on devices that are only appropriate for files" name="CERT_C-FIO32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO38_C (RULE) Do not copy a FILE object" name="CERT_C-FIO38" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO39_C (RULE) Do not alternately input and output from a stream without an intervening flush or positioning call" name="CERT_C-FIO39" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO37_C (RULE) Do not assume that fgets() or fgetws() returns a nonempty string when successful" name="CERT_C-FIO37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP44_C (RULE) Do not rely on side effects in operands to sizeof, _Alignof, or _Generic" name="CERT_C-EXP44" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP45_C (RULE) Do not perform assignments in selection statements" name="CERT_C-EXP45" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP42_C (RULE) Do not compare padding data" name="CERT_C-EXP42" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP43_C (RULE) Avoid undefined behavior when using restrict-qualified pointers" name="CERT_C-EXP43" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO30_C (RULE) Exclude user input from format strings" name="CERT_C-FIO30" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP46_C (RULE) Do not use a bitwise operator with a Boolean-like operand" name="CERT_C-EXP46" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP47_C (RULE) Do not call va_arg with an argument of the incorrect type" name="CERT_C-EXP47" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM12_C (REC) Consider using a goto chain when leaving a function on error when using and releasing resources" name="CERT_C-MEM12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR34_C (RULE) Cast characters to unsigned char before converting to larger integer sizes" name="CERT_C-STR34" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR31_C (RULE) Guarantee that storage for strings has sufficient space for character data and the null terminator" name="CERT_C-STR31" total="5">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-STR32_C (RULE) Do not pass a non-null-terminated character sequence to a library function that expects a string" name="CERT_C-STR32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR30_C (RULE) Do not attempt to modify string literals" name="CERT_C-STR30" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO45_C (RULE) Avoid TOCTOU race conditions while accessing files" name="CERT_C-FIO45" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO46_C (RULE) Do not access a closed file" name="CERT_C-FIO46" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO44_C (RULE) Only use values for fsetpos() that are returned from fgetpos()" name="CERT_C-FIO44" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR37_C (RULE) Arguments to character-handling functions must be representable as an unsigned char" name="CERT_C-STR37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR38_C (RULE) Do not confuse narrow and wide character strings and functions" name="CERT_C-STR38" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO47_C (RULE) Use valid format strings" name="CERT_C-FIO47" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO41_C (RULE) Do not call getc(), putc(), getwc(), or putwc() with a stream argument that has side effects" name="CERT_C-FIO41" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO42_C (RULE) Close files when they are no longer needed" name="CERT_C-FIO42" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO40_C (RULE) Reset strings on fgets() or fgetws() failure" name="CERT_C-FIO40" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM07_C (REC) Ensure that the arguments to calloc(), when multiplied, do not wrap" name="CERT_C-MEM07" total="1">
                  <Stats authTot="2;" total="2"/>
               </Category>
               <Category desc="CERT-MSC32_C (RULE) Properly seed pseudorandom number generators" name="CERT_C-MSC32" total="1">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-MSC33_C (RULE) Do not pass invalid data to the asctime() function" name="CERT_C-MSC33" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC38_C (RULE) Do not treat a predefined identifier as an object if it might only be implemented as a macro" name="CERT_C-MSC38" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC37_C (RULE) Ensure that control never reaches the end of a non-void function" name="CERT_C-MSC37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC39_C (RULE) Do not call va_arg() on a va_list that has an indeterminate value" name="CERT_C-MSC39" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP30_C (RULE) Do not depend on the order of evaluation for side effects" name="CERT_C-EXP30" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON40_C (RULE) Do not refer to an atomic variable twice in an expression" name="CERT_C-CON40" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP20_C (REC) Perform explicit tests to determine success, true and false, and equality" name="CERT_C-EXP20" total="2">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-CON43_C (RULE) Do not allow data races in multithreaded code" name="CERT_C-CON43" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON41_C (RULE) Wrap functions that can fail spuriously in a loop" name="CERT_C-CON41" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MSC41_C (RULE) Never hard code sensitive information" name="CERT_C-MSC41" total="1">
                  <Stats authTot="29;" total="29"/>
               </Category>
               <Category desc="CERT-MSC40_C (RULE) Do not violate constraints" name="CERT_C-MSC40" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM33_C (RULE) Allocate and copy structures containing a flexible array member dynamically" name="CERT_C-MEM33" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM34_C (RULE) Only free memory allocated dynamically" name="CERT_C-MEM34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM31_C (RULE) Free dynamically allocated memory when no longer needed" name="CERT_C-MEM31" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM35_C (RULE) Allocate sufficient memory for an object" name="CERT_C-MEM35" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG01_C (REC) Understand implementation-specific details regarding signal handler persistence" name="CERT_C-SIG01" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM36_C (RULE) Do not modify the alignment of objects by calling realloc()" name="CERT_C-MEM36" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG00_C (REC) Mask signals handled by noninterruptible signal handlers" name="CERT_C-SIG00" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-API00_C (REC) Functions should validate their parameters" name="CERT_C-API00" total="1">
                  <Stats authTot="3;" total="3"/>
               </Category>
               <Category desc="CERT-FIO24_C (REC) Do not open a file that is already open" name="CERT_C-FIO24" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-SIG02_C (REC) Avoid using signals to implement normal functionality" name="CERT_C-SIG02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO21_C (REC) Do not create temporary files in shared directories" name="CERT_C-FIO21" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO22_C (REC) Close files before spawning processes" name="CERT_C-FIO22" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP40_C (RULE) Do not modify constant objects" name="CERT_C-EXP40" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-MEM30_C (RULE) Do not access freed memory" name="CERT_C-MEM30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP33_C (RULE) Do not read uninitialized memory" name="CERT_C-EXP33" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP34_C (RULE) Do not dereference null pointers" name="CERT_C-EXP34" total="1">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-EXP32_C (RULE) Do not access a volatile object through a nonvolatile reference" name="CERT_C-EXP32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON32_C (RULE) Prevent data races when accessing bit-fields from multiple threads" name="CERT_C-CON32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP37_C (RULE) Call functions with the correct number and type of arguments" name="CERT_C-EXP37" total="3">
                  <Stats authTot="3;" total="3"/>
               </Category>
               <Category desc="CERT-CON33_C (RULE) Avoid race conditions when using library functions" name="CERT_C-CON33" total="1">
                  <Stats authTot="2;" total="2"/>
               </Category>
               <Category desc="CERT-CON30_C (RULE) Clean up thread-specific storage" name="CERT_C-CON30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP35_C (RULE) Do not modify objects with temporary lifetime" name="CERT_C-EXP35" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON31_C (RULE) Do not destroy a mutex while it is locked" name="CERT_C-CON31" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP36_C (RULE) Do not cast pointers into more strictly aligned pointer types" name="CERT_C-EXP36" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON36_C (RULE) Wrap functions that can spuriously wake up in a loop" name="CERT_C-CON36" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON37_C (RULE) Do not call signal() in a multithreaded program" name="CERT_C-CON37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON34_C (RULE) Declare objects shared between threads with appropriate storage durations" name="CERT_C-CON34" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP39_C (RULE) Do not access a variable through a pointer of an incompatible type" name="CERT_C-EXP39" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON35_C (RULE) Avoid deadlock by locking in a predefined order" name="CERT_C-CON35" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON38_C (RULE) Preserve thread safety and liveness when using condition variables" name="CERT_C-CON38" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON39_C (RULE) Do not join or detach a thread that was previously joined or detached" name="CERT_C-CON39" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL22_C (REC) Use volatile for data that cannot be cached" name="CERT_C-DCL22" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL20_C (REC) Explicitly specify void when a function accepts no arguments" name="CERT_C-DCL20" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP00_C (REC) Use parentheses for precedence of operation" name="CERT_C-EXP00" total="1">
                  <Stats authTot="6;" total="6"/>
               </Category>
               <Category desc="CERT-EXP05_C (REC) Do not cast away a const qualification" name="CERT_C-EXP05" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP02_C (REC) Be aware of the short-circuit behavior of the logical AND and OR operators" name="CERT_C-EXP02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP08_C (REC) Ensure pointer arithmetic is used correctly" name="CERT_C-EXP08" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL19_C (REC) Minimize the scope of variables and functions" name="CERT_C-DCL19" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL18_C (REC) Do not begin integer constants with 0 when specifying a decimal value" name="CERT_C-DCL18" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL12_C (REC) Implement abstract data types using opaque types" name="CERT_C-DCL12" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FIO01_C (REC) Be careful using functions that use file names for identification" name="CERT_C-FIO01" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL11_C (REC) Understand the type issues associated with variadic functions" name="CERT_C-DCL11" total="6">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL10_C (REC) Maintain the contract between the writer and caller of variadic functions" name="CERT_C-DCL10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL16_C (REC) Use &quot;L,&quot; not &quot;l,&quot; to indicate a long value" name="CERT_C-DCL16" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL15_C (REC) Declare file-scope objects or functions that do not need external linkage as static" name="CERT_C-DCL15" total="1">
                  <Stats authTot="14;" total="14"/>
               </Category>
               <Category desc="CERT-DCL13_C (REC) Declare function parameters that are pointers to values not changed by the function as const" name="CERT_C-DCL13" total="1">
                  <Stats authTot="4;" total="4"/>
               </Category>
               <Category desc="CERT-EXP12_C (REC) Do not ignore values returned by functions" name="CERT_C-EXP12" total="2">
                  <Stats authTot="35;" total="35"/>
               </Category>
               <Category desc="CERT-EXP10_C (REC) Do not depend on the order of evaluation of subexpressions or the order in which side effects take place" name="CERT_C-EXP10" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP15_C (REC) Do not place a semicolon on the same line as an if, for, or while statement" name="CERT_C-EXP15" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP16_C (REC) Do not compare function pointers to constant values" name="CERT_C-EXP16" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP14_C (REC) Beware of integer promotion when performing bitwise operations on integer types smaller than int" name="CERT_C-EXP14" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-EXP19_C (REC) Use braces for the body of an if, for, or while statement" name="CERT_C-EXP19" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR00_C (REC) Represent characters using an appropriate type" name="CERT_C-STR00" total="1">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-STR09_C (REC) Don't assume numeric values for expressions with type plain character" name="CERT_C-STR09" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR07_C (REC) Use the bounds-checking interfaces for string manipulation" name="CERT_C-STR07" total="1">
                  <Stats authTot="2;" total="2"/>
               </Category>
               <Category desc="CERT-STR04_C (REC) Use plain char for characters in the basic character set" name="CERT_C-STR04" total="1">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-STR05_C (REC) Use pointers to const when referring to string literals" name="CERT_C-STR05" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR02_C (REC) Sanitize data passed to complex subsystems" name="CERT_C-STR02" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR03_C (REC) Do not inadvertently truncate a string" name="CERT_C-STR03" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL41_C (RULE) Do not declare variables inside a switch statement before the first case label" name="CERT_C-DCL41" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL40_C (RULE) Do not create incompatible declarations of the same function or object" name="CERT_C-DCL40" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON01_C (REC) Acquire and release synchronization primitives in the same module, at the same level of abstraction" name="CERT_C-CON01" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON02_C (REC) Do not use volatile as a synchronization primitive" name="CERT_C-CON02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-CON05_C (REC) Do not perform operations that can block while holding a lock" name="CERT_C-CON05" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR11_C (REC) Do not specify the bound of a character array initialized with a string literal" name="CERT_C-STR11" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL39_C (RULE) Avoid information leakage when passing a structure across a trust boundary" name="CERT_C-DCL39" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-STR10_C (REC) Do not concatenate different type of string literals" name="CERT_C-STR10" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL31_C (RULE) Declare identifiers before using them" name="CERT_C-DCL31" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL38_C (RULE) Use the correct syntax when declaring a flexible array member" name="CERT_C-DCL38" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL37_C (RULE) Do not declare or define a reserved identifier" name="CERT_C-DCL37" total="6">
                  <Stats authTot="3;" total="3"/>
               </Category>
               <Category desc="CERT-DCL36_C (RULE) Do not declare an identifier with conflicting linkage classifications" name="CERT_C-DCL36" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL30_C (RULE) Declare objects with appropriate storage durations" name="CERT_C-DCL30" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR01_C (REC) Do not apply the sizeof operator to a pointer when taking the size of an array" name="CERT_C-ARR01" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR02_C (REC) Explicitly specify array bounds, even if implicitly defined by an initializer" name="CERT_C-ARR02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE02_C (REC) Macro replacement lists should be parenthesized" name="CERT_C-PRE02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE00_C (REC) Prefer inline or static functions to function-like macros" name="CERT_C-PRE00" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE01_C (REC) Use parentheses within macros around parameter names" name="CERT_C-PRE01" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE06_C (REC) Enclose header files in an include guard" name="CERT_C-PRE06" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-PRE07_C (REC) Avoid using repeated question marks" name="CERT_C-PRE07" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS54_C (RULE) Detect and handle POSIX library errors" name="CERT_C-POS54" total="1">
                  <Stats authTot="15;" total="15"/>
               </Category>
               <Category desc="CERT-ERR30_C (RULE) Set errno to zero before calling a library function known to set errno, and check errno only after the function returns a value indicating failure" name="CERT_C-ERR30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR32_C (RULE) Do not rely on indeterminate values of errno" name="CERT_C-ERR32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR33_C (RULE) Detect and handle standard library errors" name="CERT_C-ERR33" total="3">
                  <Stats authTot="29;" total="29"/>
               </Category>
               <Category desc="CERT-ERR34_C (RULE) Detect errors when converting a string to a number" name="CERT_C-ERR34" total="1">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-POS51_C (RULE) Avoid deadlock with POSIX threads by locking in predefined order" name="CERT_C-POS51" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS50_C (RULE) Declare objects shared between POSIX threads with appropriate storage durations" name="CERT_C-POS50" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS53_C (RULE) Do not use more than one mutex for concurrent waiting operations on a condition variable" name="CERT_C-POS53" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS52_C (RULE) Do not perform operations that can block while holding a POSIX lock" name="CERT_C-POS52" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR06_C (REC) Understand the termination behavior of assert() and abort()" name="CERT_C-ERR06" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR07_C (REC) Prefer functions that support error checking over equivalent functions that don't" name="CERT_C-ERR07" total="2">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-DCL06_C (REC) Use meaningful symbolic constants to represent literal values" name="CERT_C-DCL06" total="1">
                  <Stats authTot="5;" total="5"/>
               </Category>
               <Category desc="CERT-DCL01_C (REC) Do not reuse variable names in subscopes" name="CERT_C-DCL01" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL00_C (REC) Const-qualify immutable objects" name="CERT_C-DCL00" total="2">
                  <Stats authTot="7;" total="7"/>
               </Category>
               <Category desc="CERT-DCL05_C (REC) Use typedefs of non-pointer types only" name="CERT_C-DCL05" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL04_C (REC) Do not declare more than one variable per declaration" name="CERT_C-DCL04" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-DCL02_C (REC) Use visually distinct identifiers" name="CERT_C-DCL02" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS44_C (RULE) Do not use signals to terminate threads" name="CERT_C-POS44" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS48_C (RULE) Do not unlock or destroy another POSIX thread's mutex" name="CERT_C-POS48" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS47_C (RULE) Do not use threads that can be canceled asynchronously" name="CERT_C-POS47" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS49_C (RULE) When data must be accessed by multiple threads, provide a mutex and guarantee no adjacent data is also accessed" name="CERT_C-POS49" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-WIN30_C (RULE) Properly pair allocation and deallocation functions" name="CERT_C-WIN30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR01_C (REC) Use ferror() rather than errno to check for FILE stream errors" name="CERT_C-ERR01" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ERR02_C (REC) Avoid in-band error indicators" name="CERT_C-ERR02" total="1">
                  <Stats authTot="16;" total="16"/>
               </Category>
               <Category desc="CERT-ERR04_C (REC) Choose an appropriate termination strategy" name="CERT_C-ERR04" total="3">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-ERR05_C (REC) Application-independent code should provide error detection without dictating error handling" name="CERT_C-ERR05" total="3">
                  <Stats authTot="1;" total="1"/>
               </Category>
               <Category desc="CERT-FLP37_C (RULE) Do not use object representations to compare floating-point values" name="CERT_C-FLP37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP36_C (RULE) Preserve precision when converting integral values to floating-point type" name="CERT_C-FLP36" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP34_C (RULE) Ensure that floating-point conversions are within range of the new type" name="CERT_C-FLP34" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS33_C (RULE) Do not use vfork()" name="CERT_C-POS33" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR32_C (RULE) Ensure size arguments for variable length arrays are in a valid range" name="CERT_C-ARR32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS35_C (RULE) Avoid race conditions while checking for the existence of a symbolic link" name="CERT_C-POS35" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS34_C (RULE) Do not call putenv() with a pointer to an automatic variable as the argument" name="CERT_C-POS34" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR30_C (RULE) Do not form or use out-of-bounds pointers or array subscripts" name="CERT_C-ARR30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS37_C (RULE) Ensure that privilege relinquishment is successful" name="CERT_C-POS37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP32_C (RULE) Prevent or detect domain and range errors in math functions" name="CERT_C-FLP32" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS36_C (RULE) Observe correct revocation order while relinquishing privileges" name="CERT_C-POS36" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS39_C (RULE) Use the correct byte ordering when transferring data between systems" name="CERT_C-POS39" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-FLP30_C (RULE) Do not use floating-point variables as loop counters" name="CERT_C-FLP30" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS38_C (RULE) Beware of race conditions when using fork and file descriptors" name="CERT_C-POS38" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR39_C (RULE) Do not add or subtract a scaled integer to a pointer" name="CERT_C-ARR39" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR38_C (RULE) Guarantee that library functions do not form invalid pointers" name="CERT_C-ARR38" total="4">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR37_C (RULE) Do not add or subtract an integer to a pointer to a non-array object" name="CERT_C-ARR37" total="1">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-ARR36_C (RULE) Do not subtract or compare two pointers that do not refer to the same array" name="CERT_C-ARR36" total="2">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Category desc="CERT-POS30_C (RULE) Use the readlink() function properly" name="CERT_C-POS30" total="3">
                  <Stats authTot="0;" total="0"/>
               </Category>
               <Stats authTot="0;" total="0"/>
            </Category>
         </CategoriesList>
         <SeverityList>
            <Severity id="1">
               <Stats authTot="83;" total="83"/>
            </Severity>
            <Severity id="2">
               <Stats authTot="18;" total="18"/>
            </Severity>
            <Severity id="3">
               <Stats authTot="111;" total="111"/>
            </Severity>
         </SeverityList>
      </Rules>
      
  <StdViols>
    <StdViol msg="Do not declare the 'ECU_ROAD' identifier since this name is a reserved macro name" ln="35" sev="3" auth="danie" rule="CERT_C-DCL37-d" tool="c++test" cat="CERT_C-DCL37" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="35" locStartPos="4" locEndLn="35" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Do not declare the 'ECU_RACE' identifier since this name is a reserved macro name" ln="36" sev="3" auth="danie" rule="CERT_C-DCL37-d" tool="c++test" cat="CERT_C-DCL37" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="36" locStartPos="4" locEndLn="36" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Do not declare the 'ECUType' identifier since this name is a reserved macro name" ln="37" sev="3" auth="danie" rule="CERT_C-DCL37-d" tool="c++test" cat="CERT_C-DCL37" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="37" locStartPos="2" locEndLn="37" locEndPos="3" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Do not use the literal constant '3'" ln="50" sev="3" auth="danie" rule="CERT_C-DCL06-a" tool="c++test" cat="CERT_C-DCL06" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="50" locStartPos="22" locEndLn="50" locEndPos="23" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Global variable 'maps' has external linkage and is not declared in the header" ln="54" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="54" locStartPos="12" locEndLn="54" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: R_A" ln="55" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="55" locStartPos="5" locEndLn="55" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: Road A - basic" ln="55" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="55" locStartPos="12" locEndLn="55" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: R_B" ln="56" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="56" locStartPos="5" locEndLn="56" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: Road B - intermediate" ln="56" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="56" locStartPos="12" locEndLn="56" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: R_C" ln="57" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="57" locStartPos="5" locEndLn="57" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: Road C - advanced" ln="57" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="57" locStartPos="12" locEndLn="57" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: Race A - 65 HP" ln="58" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="58" locStartPos="12" locEndLn="58" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: X_A" ln="58" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="58" locStartPos="5" locEndLn="58" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: Race B - 77 HP" ln="59" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="59" locStartPos="12" locEndLn="59" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: X_B" ln="59" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="59" locStartPos="5" locEndLn="59" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: Race C - 100 HP" ln="60" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="60" locStartPos="12" locEndLn="60" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: X_C" ln="60" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="60" locStartPos="5" locEndLn="60" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Global variable 'vehicles' has external linkage and is not declared in the header" ln="63" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="63" locStartPos="12" locEndLn="63" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: 123456" ln="64" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="64" locStartPos="5" locEndLn="64" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: R_A" ln="64" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="64" locStartPos="29" locEndLn="64" locEndPos="30" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: R_B" ln="64" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="64" locStartPos="36" locEndLn="64" locEndPos="37" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: R_C" ln="64" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="64" locStartPos="43" locEndLn="64" locEndPos="44" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: 234567" ln="65" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="65" locStartPos="5" locEndLn="65" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: R_A" ln="65" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="65" locStartPos="29" locEndLn="65" locEndPos="30" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: R_B" ln="65" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="65" locStartPos="36" locEndLn="65" locEndPos="37" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: 345678" ln="66" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="66" locStartPos="5" locEndLn="66" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: R_A" ln="66" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="66" locStartPos="29" locEndLn="66" locEndPos="30" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: R_B" ln="66" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="66" locStartPos="36" locEndLn="66" locEndPos="37" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: R_C" ln="66" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="66" locStartPos="43" locEndLn="66" locEndPos="44" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Global variable 'current_vin' has external linkage and is not declared in the header" ln="69" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="69" locStartPos="5" locEndLn="69" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Global variable 'current_ecu_type' has external linkage and is not declared in the header" ln="70" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="70" locStartPos="8" locEndLn="70" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Global variable 'current_min_license' has external linkage and is not declared in the header" ln="71" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="71" locStartPos="4" locEndLn="71" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Global variable 'vin_verification' has external linkage and is not declared in the header" ln="73" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="73" locStartPos="4" locEndLn="73" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Do not use the literal constant '512'" ln="75" sev="3" auth="danie" rule="CERT_C-DCL06-a" tool="c++test" cat="CERT_C-DCL06" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="75" locStartPos="16" locEndLn="75" locEndPos="17" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Global variable 'log_buffer' has external linkage and is not declared in the header" ln="75" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="75" locStartPos="5" locEndLn="75" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Function 'init_system' has external linkage and is not declared in the header" ln="77" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="77" locStartPos="5" locEndLn="77" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Implicit conversion from 'signed long' type to 'unsigned int' type in function's argument" ln="78" sev="2" auth="danie" rule="CERT_C-INT02-a" tool="c++test" cat="CERT_C-INT02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="78" locStartPos="10" locEndLn="78" locEndPos="11" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Result of &quot;time&quot; passed to library function &quot;srand&quot; without being checked" ln="78" sev="2" auth="danie" rule="CERT_C-MEM07-a" tool="c++test" cat="CERT_C-MEM07" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="78" locStartPos="4" locEndLn="78" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Result of &quot;time&quot; passed to library function &quot;srand&quot; without being checked" ln="78" sev="2" auth="danie" rule="CERT_C-MEM04-a" tool="c++test" cat="CERT_C-MEM04" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="78" locStartPos="4" locEndLn="78" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'srand' function should not be used in multithreading applications" ln="78" sev="3" auth="danie" rule="CERT_C-CON33-a" tool="c++test" cat="CERT_C-CON33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="78" locStartPos="4" locEndLn="78" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The argument number '1' ('essentially signed' type) is passed to the function 'srand' as a parameter with the 'essentially unsigned' type" ln="78" sev="2" auth="danie" rule="CERT_C-INT31-i" tool="c++test" cat="CERT_C-INT31" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="78" locStartPos="10" locEndLn="78" locEndPos="11" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;time&quot; should be checked" ln="78" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="-889040200" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="78" locStartPos="0" locEndLn="79" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="78" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="79" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="78" srcRngStartPos="0" srcRngEndLn="79" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="78" ElType=".C" desc="time(...)" rngLn="78">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="78" srcRngStartPos="0" srcRngEndLn="79" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="78" ElType=".P" desc="srand(time(NULL));" rngLn="78">
          <Anns>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Declare parameter 'map_id' as const" ln="82" sev="3" auth="danie" rule="CERT_C-DCL00-b" tool="c++test" cat="CERT_C-DCL00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="82" locStartPos="28" locEndLn="82" locEndPos="29" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Function 'find_map' has external linkage and is not declared in the header" ln="82" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="82" locStartPos="13" locEndLn="82" locEndPos="14" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Pass parameter &quot;map_id&quot; with const specifier" ln="82" sev="3" auth="danie" rule="CERT_C-DCL13-a" tool="c++test" cat="CERT_C-DCL13" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="82" locStartPos="28" locEndLn="82" locEndPos="29" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Declare parameter 'map_id' as const" ln="92" sev="3" auth="danie" rule="CERT_C-DCL00-b" tool="c++test" cat="CERT_C-DCL00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="92" locStartPos="33" locEndLn="92" locEndPos="34" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Declare parameter 'vehicle' as const" ln="92" sev="3" auth="danie" rule="CERT_C-DCL00-b" tool="c++test" cat="CERT_C-DCL00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="92" locStartPos="54" locEndLn="92" locEndPos="55" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Function 'is_map_allowed_for_vin' has external linkage and is not declared in the header" ln="92" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="92" locStartPos="4" locEndLn="92" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Parameter 'vehicle' is not validated before use" ln="92" sev="3" auth="danie" rule="CERT_C-API00-a" tool="c++test" cat="CERT_C-API00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="92" locStartPos="54" locEndLn="92" locEndPos="55" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Pass parameter &quot;map_id&quot; with const specifier" ln="92" sev="3" auth="danie" rule="CERT_C-DCL13-a" tool="c++test" cat="CERT_C-DCL13" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="92" locStartPos="33" locEndLn="92" locEndPos="34" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Pass parameter &quot;vehicle&quot; with const specifier" ln="92" sev="3" auth="danie" rule="CERT_C-DCL13-a" tool="c++test" cat="CERT_C-DCL13" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="92" locStartPos="54" locEndLn="92" locEndPos="55" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="&quot;vehicle&quot; may possibly be null" ln="94" ruleSAFMsg="Null pointer dereferencing point" auth="danie" sev="1" rule="CERT_C-EXP34-a" ruleSCSCMsg="Source of null value" tool="c++test" id="-1110275384" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="94" locStartPos="0" locEndLn="95" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="168" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="169" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="155" srcRngStartPos="0" srcRngEndLn="156" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="155" ElType="." desc="if (current_vin[0] == '\0') {" rngLn="155">
          <Anns>
            <Ann msg="Condition evaluation: (current_vin[0] == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="161" srcRngStartPos="0" srcRngEndLn="162" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="161" ElType="." desc="IgnitionMap* map = find_map(map_id);" rngLn="161">
          <ElDescList>
            <ElDesc srcRngStartln="83" srcRngStartPos="0" srcRngEndLn="84" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="83" ElType="." desc="int i;" rngLn="83"/>
            <ElDesc srcRngStartln="84" srcRngStartPos="0" srcRngEndLn="85" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="84" ElType="." desc="for (i = 0; i &lt; MAX_MAPS; i++) {" rngLn="84">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt; 6) (true)" kind="condEval"/>
                <Ann msg="Entering the loop" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="85" srcRngStartPos="0" srcRngEndLn="86" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="85" ElType="." desc="if (strcmp(maps[i].id, map_id) == 0) {" rngLn="85">
              <Anns>
                <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="86" srcRngStartPos="0" srcRngEndLn="87" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="86" ElType="." desc="return &amp;maps[i];" rngLn="86"/>
          </ElDescList>
        </ElDesc>
        <ElDesc srcRngStartln="162" srcRngStartPos="0" srcRngEndLn="163" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="162" ElType="." desc="if (map == NULL) {" rngLn="162">
          <Anns>
            <Ann msg="Condition evaluation: (map == 0) (false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="168" srcRngStartPos="0" srcRngEndLn="169" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="168" ElType=".C" desc="VehicleInfo* vehicle = NULL;" rngLn="168">
          <Anns>
            <Ann msg="Source of null value" kind="cause"/>
            <Ann msg="Null value carrier: vehicle" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="169" srcRngStartPos="0" srcRngEndLn="170" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="169" ElType="." desc="int i;" rngLn="169"/>
        <ElDesc srcRngStartln="170" srcRngStartPos="0" srcRngEndLn="171" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="170" ElType="." desc="for (i = 0; i &lt; MAX_VINS; i++) {" rngLn="170">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; 3) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="171" srcRngStartPos="0" srcRngEndLn="172" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="171" ElType="." desc="if (strcmp(vehicles[i].vin, current_vin) == 0) {" rngLn="171">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="170" srcRngStartPos="0" srcRngEndLn="171" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="170" ElType="." desc="for (i = 0; i &lt; MAX_VINS; i++) {" rngLn="170">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; 3) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="171" srcRngStartPos="0" srcRngEndLn="172" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="171" ElType="." desc="if (strcmp(vehicles[i].vin, current_vin) == 0) {" rngLn="171">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="170" srcRngStartPos="0" srcRngEndLn="171" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="170" ElType="." desc="for (i = 0; i &lt; MAX_VINS; i++) {" rngLn="170">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; 3) (false)" kind="condEval"/>
            <Ann msg="Not entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="177" srcRngStartPos="0" srcRngEndLn="178" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="177" ElType="." desc="printf(&quot;PROMPT: Re-enter VIN from motorcycle documents for verification:\n&quot;);" rngLn="177"/>
        <ElDesc srcRngStartln="178" srcRngStartPos="0" srcRngEndLn="179" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="178" ElType="." desc="fflush(stdout);" rngLn="178"/>
        <ElDesc srcRngStartln="180" srcRngStartPos="0" srcRngEndLn="181" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="180" ElType="." desc="scanf(&quot;%d&quot;, &amp;vin_verification);" rngLn="180"/>
        <ElDesc srcRngStartln="182" srcRngStartPos="0" srcRngEndLn="183" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="182" ElType="." desc="int current_vin_num = atoi(current_vin);" rngLn="182"/>
        <ElDesc srcRngStartln="184" srcRngStartPos="0" srcRngEndLn="185" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="184" ElType="." desc="if (vin_verification == current_vin_num) {" rngLn="184">
          <Anns>
            <Ann msg="Condition evaluation: (vin_verification == current_vin_num) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="190" srcRngStartPos="0" srcRngEndLn="191" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="190" ElType="." desc="} else if (vin_verification >= 100000 &amp;&amp; vin_verification &lt;= 999999) {" rngLn="190">
          <Anns>
            <Ann msg="Condition evaluation: (vin_verification >= 100000) (assuming false)" kind="condEval"/>
            <Ann msg="Condition evaluation: vin_verification >= 100000 &amp;&amp; vin_verification &lt;= 999999 (false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="196" srcRngStartPos="0" srcRngEndLn="197" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="196" ElType="!" desc="is_map_allowed_for_vin(...)" rngLn="196">
          <ElDescList>
            <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="93" ElType="." desc="int i;" rngLn="93"/>
            <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="94" ElType=".P" desc="for (i = 0; i &lt; vehicle->num_allowed_maps; i++) {" rngLn="94">
              <Anns>
                <Ann msg="Null value carrier: vehicle" kind="comment"/>
                <Ann msg="Null pointer dereferencing point" kind="point"/>
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;vehicle&quot; may possibly be null" ln="94" ruleSAFMsg="Null pointer dereferencing point" auth="danie" sev="3" rule="CERT_C-MSC19-b" ruleSCSCMsg="Source of null value" tool="c++test" id="463479728" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="94" locStartPos="0" locEndLn="95" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="168" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="169" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="155" srcRngStartPos="0" srcRngEndLn="156" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="155" ElType="." desc="if (current_vin[0] == '\0') {" rngLn="155">
          <Anns>
            <Ann msg="Condition evaluation: (current_vin[0] == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="161" srcRngStartPos="0" srcRngEndLn="162" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="161" ElType="." desc="IgnitionMap* map = find_map(map_id);" rngLn="161">
          <ElDescList>
            <ElDesc srcRngStartln="83" srcRngStartPos="0" srcRngEndLn="84" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="83" ElType="." desc="int i;" rngLn="83"/>
            <ElDesc srcRngStartln="84" srcRngStartPos="0" srcRngEndLn="85" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="84" ElType="." desc="for (i = 0; i &lt; MAX_MAPS; i++) {" rngLn="84">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt; 6) (true)" kind="condEval"/>
                <Ann msg="Entering the loop" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="85" srcRngStartPos="0" srcRngEndLn="86" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="85" ElType="." desc="if (strcmp(maps[i].id, map_id) == 0) {" rngLn="85">
              <Anns>
                <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="86" srcRngStartPos="0" srcRngEndLn="87" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="86" ElType="." desc="return &amp;maps[i];" rngLn="86"/>
          </ElDescList>
        </ElDesc>
        <ElDesc srcRngStartln="162" srcRngStartPos="0" srcRngEndLn="163" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="162" ElType="." desc="if (map == NULL) {" rngLn="162">
          <Anns>
            <Ann msg="Condition evaluation: (map == 0) (false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="168" srcRngStartPos="0" srcRngEndLn="169" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="168" ElType=".C" desc="VehicleInfo* vehicle = NULL;" rngLn="168">
          <Anns>
            <Ann msg="Source of null value" kind="cause"/>
            <Ann msg="Null value carrier: vehicle" kind="comment"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="169" srcRngStartPos="0" srcRngEndLn="170" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="169" ElType="." desc="int i;" rngLn="169"/>
        <ElDesc srcRngStartln="170" srcRngStartPos="0" srcRngEndLn="171" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="170" ElType="." desc="for (i = 0; i &lt; MAX_VINS; i++) {" rngLn="170">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; 3) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="171" srcRngStartPos="0" srcRngEndLn="172" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="171" ElType="." desc="if (strcmp(vehicles[i].vin, current_vin) == 0) {" rngLn="171">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="170" srcRngStartPos="0" srcRngEndLn="171" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="170" ElType="." desc="for (i = 0; i &lt; MAX_VINS; i++) {" rngLn="170">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; 3) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="171" srcRngStartPos="0" srcRngEndLn="172" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="171" ElType="." desc="if (strcmp(vehicles[i].vin, current_vin) == 0) {" rngLn="171">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="170" srcRngStartPos="0" srcRngEndLn="171" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="170" ElType="." desc="for (i = 0; i &lt; MAX_VINS; i++) {" rngLn="170">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; 3) (false)" kind="condEval"/>
            <Ann msg="Not entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="177" srcRngStartPos="0" srcRngEndLn="178" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="177" ElType="." desc="printf(&quot;PROMPT: Re-enter VIN from motorcycle documents for verification:\n&quot;);" rngLn="177"/>
        <ElDesc srcRngStartln="178" srcRngStartPos="0" srcRngEndLn="179" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="178" ElType="." desc="fflush(stdout);" rngLn="178"/>
        <ElDesc srcRngStartln="180" srcRngStartPos="0" srcRngEndLn="181" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="180" ElType="." desc="scanf(&quot;%d&quot;, &amp;vin_verification);" rngLn="180"/>
        <ElDesc srcRngStartln="182" srcRngStartPos="0" srcRngEndLn="183" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="182" ElType="." desc="int current_vin_num = atoi(current_vin);" rngLn="182"/>
        <ElDesc srcRngStartln="184" srcRngStartPos="0" srcRngEndLn="185" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="184" ElType="." desc="if (vin_verification == current_vin_num) {" rngLn="184">
          <Anns>
            <Ann msg="Condition evaluation: (vin_verification == current_vin_num) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="190" srcRngStartPos="0" srcRngEndLn="191" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="190" ElType="." desc="} else if (vin_verification >= 100000 &amp;&amp; vin_verification &lt;= 999999) {" rngLn="190">
          <Anns>
            <Ann msg="Condition evaluation: (vin_verification >= 100000) (assuming false)" kind="condEval"/>
            <Ann msg="Condition evaluation: vin_verification >= 100000 &amp;&amp; vin_verification &lt;= 999999 (false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="196" srcRngStartPos="0" srcRngEndLn="197" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="196" ElType="!" desc="is_map_allowed_for_vin(...)" rngLn="196">
          <ElDescList>
            <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="93" ElType="." desc="int i;" rngLn="93"/>
            <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="94" ElType=".P" desc="for (i = 0; i &lt; vehicle->num_allowed_maps; i++) {" rngLn="94">
              <Anns>
                <Ann msg="Null value carrier: vehicle" kind="comment"/>
                <Ann msg="Null pointer dereferencing point" kind="point"/>
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Function 'cmd_identify' has external linkage and is not declared in the header" ln="102" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="102" locStartPos="5" locEndLn="102" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="The &quot;srand&quot; function should be called before the call to the &quot;rand&quot; function to seed pseudo-random number generator" ln="103" ruleSAFMsg="Point where the method is called" auth="danie" sev="1" rule="CERT_C-MSC32-d" ruleSCSCMsg="Start of the path" tool="c++test" id="1232779629" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="103" locStartPos="0" locEndLn="104" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="102" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="103" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="102" srcRngStartPos="0" srcRngEndLn="103" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="102" ElType=".C" desc="void cmd_identify() {" rngLn="102">
          <Anns>
            <Ann msg="Start of the path" kind="cause"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="103" srcRngStartPos="0" srcRngEndLn="104" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="103" ElType=".P" desc="rand()" rngLn="103">
          <Anns>
            <Ann msg="Point where the method is called" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The 'rand' function should not be used in multithreading applications" ln="103" sev="3" auth="danie" rule="CERT_C-CON33-a" tool="c++test" cat="CERT_C-CON33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="103" locStartPos="23" locEndLn="103" locEndPos="24" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The left-hand-side operand of the '%' operator should be of the unsigned integer type instead of the 'int' type" ln="103" sev="3" auth="danie" rule="CERT_C-INT10-a" tool="c++test" cat="CERT_C-INT10" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="103" locStartPos="23" locEndLn="103" locEndPos="24" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The library function 'rand()' should not be used" ln="103" sev="2" auth="danie" rule="CERT_C-MSC30-a" tool="c++test" cat="CERT_C-MSC30" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="103" locStartPos="23" locEndLn="103" locEndPos="24" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Declare local variable 'vehicle' as const" ln="104" sev="3" auth="danie" rule="CERT_C-DCL00-a" tool="c++test" cat="CERT_C-DCL00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="104" locStartPos="17" locEndLn="104" locEndPos="18" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Avoid using unsafe string function 'strcpy' in your program" ln="106" sev="1" auth="danie" rule="CERT_C-STR31-e" tool="c++test" cat="CERT_C-STR31" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="106" locStartPos="4" locEndLn="106" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Avoid using unsafe string function 'strcpy' in your program" ln="106" sev="3" auth="danie" rule="CERT_C-MSC24-c" tool="c++test" cat="CERT_C-MSC24" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="106" locStartPos="4" locEndLn="106" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Avoid using unsafe string function 'strcpy' in your program" ln="106" sev="1" auth="danie" rule="CERT_C-ENV01-b" tool="c++test" cat="CERT_C-ENV01" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="106" locStartPos="4" locEndLn="106" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Avoid using unsafe string function 'strcpy' in your program" ln="106" sev="2" auth="danie" rule="CERT_C-API02-a" tool="c++test" cat="CERT_C-API02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="106" locStartPos="4" locEndLn="106" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Avoid using unsafe string function 'strcpy' in your program" ln="106" sev="3" auth="danie" rule="CERT_C-API01-b" tool="c++test" cat="CERT_C-API01" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="106" locStartPos="4" locEndLn="106" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'strcpy' should be used" ln="106" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="106" locStartPos="4" locEndLn="106" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unsafe functions 'strcpy' is being used" ln="106" sev="3" auth="danie" rule="CERT_C-MSC24-d" tool="c++test" cat="CERT_C-MSC24" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="106" locStartPos="4" locEndLn="106" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unsafe functions 'strcpy' is being used" ln="106" sev="1" auth="danie" rule="CERT_C-ENV01-a" tool="c++test" cat="CERT_C-ENV01" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="106" locStartPos="4" locEndLn="106" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unsafe functions 'strcpy' is being used" ln="106" sev="2" auth="danie" rule="CERT_C-API02-b" tool="c++test" cat="CERT_C-API02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="106" locStartPos="4" locEndLn="106" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;strcpy&quot; return value" ln="106" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="106" locStartPos="4" locEndLn="106" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Values &quot;current_vin, vehicle, vin&quot; passed to library function &quot;strcpy&quot; without being checked" ln="106" sev="2" auth="danie" rule="CERT_C-MEM07-a" tool="c++test" cat="CERT_C-MEM07" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="106" locStartPos="4" locEndLn="106" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Values &quot;current_vin, vehicle, vin&quot; passed to library function &quot;strcpy&quot; without being checked" ln="106" sev="2" auth="danie" rule="CERT_C-MEM04-a" tool="c++test" cat="CERT_C-MEM04" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="106" locStartPos="4" locEndLn="106" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="110" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="110" locStartPos="4" locEndLn="110" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Use parenthesis to clarify order ('==' is the first operand of '?:')" ln="112" sev="3" auth="danie" rule="CERT_C-EXP00-a" tool="c++test" cat="CERT_C-EXP00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="112" locStartPos="11" locEndLn="112" locEndPos="12" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="116" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="116" locStartPos="8" locEndLn="116" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Use parenthesis to clarify order ('-' is the second operand of '&lt;')" ln="117" sev="3" auth="danie" rule="CERT_C-EXP00-a" tool="c++test" cat="CERT_C-EXP00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="117" locStartPos="16" locEndLn="117" locEndPos="17" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="118" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="118" locStartPos="12" locEndLn="118" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="121" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="121" locStartPos="4" locEndLn="121" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="122" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="122" locStartPos="4" locEndLn="122" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="122" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="122" locStartPos="4" locEndLn="122" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="122" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="122" locStartPos="4" locEndLn="122" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="122" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="122" locStartPos="4" locEndLn="122" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="122" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="50354939" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="122" locStartPos="0" locEndLn="123" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="122" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="123" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="103" srcRngStartPos="0" srcRngEndLn="104" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="103" ElType="." desc="int selected_idx = rand() % MAX_VINS;" rngLn="103"/>
        <ElDesc srcRngStartln="104" srcRngStartPos="0" srcRngEndLn="105" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="104" ElType="." desc="VehicleInfo* vehicle = &amp;vehicles[selected_idx];" rngLn="104"/>
        <ElDesc srcRngStartln="106" srcRngStartPos="0" srcRngEndLn="107" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="106" ElType="." desc="strcpy(current_vin, vehicle->vin);" rngLn="106"/>
        <ElDesc srcRngStartln="107" srcRngStartPos="0" srcRngEndLn="108" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="107" ElType="." desc="current_ecu_type = vehicle->ecu_type;" rngLn="107"/>
        <ElDesc srcRngStartln="108" srcRngStartPos="0" srcRngEndLn="109" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="108" ElType="." desc="current_min_license = vehicle->min_license_grade;" rngLn="108"/>
        <ElDesc srcRngStartln="110" srcRngStartPos="0" srcRngEndLn="111" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="110" ElType="." desc="printf(&quot;VIN: %s, ECU: %s, allowed_maps: &quot;," rngLn="110"/>
        <ElDesc srcRngStartln="112" srcRngStartPos="0" srcRngEndLn="113" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="112" ElType="." desc="current_ecu_type == ECU_ROAD ? &quot;ROAD&quot; : &quot;RACE&quot;);" rngLn="112">
          <Anns>
            <Ann msg="Condition evaluation: (current_ecu_type == 0) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="110" srcRngStartPos="0" srcRngEndLn="111" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="110" ElType="." desc="printf(&quot;VIN: %s, ECU: %s, allowed_maps: &quot;," rngLn="110"/>
        <ElDesc srcRngStartln="114" srcRngStartPos="0" srcRngEndLn="115" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="114" ElType="." desc="int i;" rngLn="114"/>
        <ElDesc srcRngStartln="115" srcRngStartPos="0" srcRngEndLn="116" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="115" ElType="." desc="for (i = 0; i &lt; vehicle->num_allowed_maps; i++) {" rngLn="115">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; vehicle->num_allowed_maps) (assuming false)" kind="condEval"/>
            <Ann msg="Not entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="121" srcRngStartPos="0" srcRngEndLn="122" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="121" ElType="." desc="printf(&quot;\n&quot;);" rngLn="121"/>
        <ElDesc srcRngStartln="122" srcRngStartPos="0" srcRngEndLn="123" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="122" ElType="CP" desc="fflush(stdout);" rngLn="122">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Function 'cmd_get_allowed_maps' has external linkage and is not declared in the header" ln="125" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="125" locStartPos="5" locEndLn="125" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="127" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="127" locStartPos="8" locEndLn="127" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="128" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="128" locStartPos="8" locEndLn="128" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="128" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="128" locStartPos="8" locEndLn="128" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="128" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="128" locStartPos="8" locEndLn="128" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="128" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="128" locStartPos="8" locEndLn="128" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="128" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="1434445577" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="128" locStartPos="0" locEndLn="129" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="128" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="129" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="126" srcRngStartPos="0" srcRngEndLn="127" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="126" ElType="." desc="if (current_vin[0] == '\0') {" rngLn="126">
          <Anns>
            <Ann msg="Condition evaluation: (current_vin[0] == 0) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="127" srcRngStartPos="0" srcRngEndLn="128" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="127" ElType="." desc="printf(&quot;ERROR: No vehicle identified\n&quot;);" rngLn="127"/>
        <ElDesc srcRngStartln="128" srcRngStartPos="0" srcRngEndLn="129" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="128" ElType="CP" desc="fflush(stdout);" rngLn="128">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Test of a value against zero should be made explicit" ln="141" sev="1" auth="danie" rule="CERT_C-EXP20-b" tool="c++test" cat="CERT_C-EXP20" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="141" locStartPos="4" locEndLn="141" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="142" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="142" locStartPos="8" locEndLn="142" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="144" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="144" locStartPos="12" locEndLn="144" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Use parenthesis to clarify order ('-' is the second operand of '&lt;')" ln="145" sev="3" auth="danie" rule="CERT_C-EXP00-a" tool="c++test" cat="CERT_C-EXP00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="145" locStartPos="20" locEndLn="145" locEndPos="21" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="146" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="146" locStartPos="16" locEndLn="146" locEndPos="17" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="149" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="149" locStartPos="8" locEndLn="149" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="150" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="150" locStartPos="8" locEndLn="150" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="150" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="150" locStartPos="8" locEndLn="150" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="150" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="150" locStartPos="8" locEndLn="150" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="150" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="150" locStartPos="8" locEndLn="150" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="150" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="1762118456" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="150" locStartPos="0" locEndLn="151" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="150" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="151" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="126" srcRngStartPos="0" srcRngEndLn="127" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="126" ElType="." desc="if (current_vin[0] == '\0') {" rngLn="126">
          <Anns>
            <Ann msg="Condition evaluation: (current_vin[0] == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="132" srcRngStartPos="0" srcRngEndLn="133" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="132" ElType="." desc="VehicleInfo* vehicle = NULL;" rngLn="132"/>
        <ElDesc srcRngStartln="133" srcRngStartPos="0" srcRngEndLn="134" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="133" ElType="." desc="int i;" rngLn="133"/>
        <ElDesc srcRngStartln="134" srcRngStartPos="0" srcRngEndLn="135" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="134" ElType="." desc="for (i = 0; i &lt; MAX_VINS; i++) {" rngLn="134">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; 3) (true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="135" srcRngStartPos="0" srcRngEndLn="136" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="135" ElType="." desc="if (strcmp(vehicles[i].vin, current_vin) == 0) {" rngLn="135">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="136" srcRngStartPos="0" srcRngEndLn="137" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="136" ElType="." desc="vehicle = &amp;vehicles[i];" rngLn="136"/>
        <ElDesc srcRngStartln="137" srcRngStartPos="0" srcRngEndLn="138" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="137" ElType="." desc="break;" rngLn="137">
          <Anns>
            <Ann msg="Exit the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="141" srcRngStartPos="0" srcRngEndLn="142" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="141" ElType="." desc="if (vehicle) {" rngLn="141">
          <Anns>
            <Ann msg="Condition evaluation: (vehicle != 0) (true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="142" srcRngStartPos="0" srcRngEndLn="143" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="142" ElType="." desc="printf(&quot;ALLOWED_MAPS: &quot;);" rngLn="142"/>
        <ElDesc srcRngStartln="143" srcRngStartPos="0" srcRngEndLn="144" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="143" ElType="." desc="for (i = 0; i &lt; vehicle->num_allowed_maps; i++) {" rngLn="143">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; vehicle->num_allowed_maps) (assuming false)" kind="condEval"/>
            <Ann msg="Not entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="149" srcRngStartPos="0" srcRngEndLn="150" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="149" ElType="." desc="printf(&quot;\n&quot;);" rngLn="149"/>
        <ElDesc srcRngStartln="150" srcRngStartPos="0" srcRngEndLn="151" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="150" ElType="CP" desc="fflush(stdout);" rngLn="150">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Function 'flash_map' has external linkage and is not declared in the header" ln="154" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="154" locStartPos="5" locEndLn="154" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Parameter 'map_id' is not validated before use" ln="154" sev="3" auth="danie" rule="CERT_C-API00-a" tool="c++test" cat="CERT_C-API00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="154" locStartPos="21" locEndLn="154" locEndPos="22" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="156" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="156" locStartPos="8" locEndLn="156" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="157" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="157" locStartPos="8" locEndLn="157" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="157" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="157" locStartPos="8" locEndLn="157" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="157" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="157" locStartPos="8" locEndLn="157" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="157" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="157" locStartPos="8" locEndLn="157" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="157" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="-1559706320" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="157" locStartPos="0" locEndLn="158" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="157" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="158" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="155" srcRngStartPos="0" srcRngEndLn="156" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="155" ElType="." desc="if (current_vin[0] == '\0') {" rngLn="155">
          <Anns>
            <Ann msg="Condition evaluation: (current_vin[0] == 0) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="156" srcRngStartPos="0" srcRngEndLn="157" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="156" ElType="." desc="printf(&quot;ERROR: No vehicle identified. Use IDENTIFY first.\n&quot;);" rngLn="156"/>
        <ElDesc srcRngStartln="157" srcRngStartPos="0" srcRngEndLn="158" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="157" ElType="CP" desc="fflush(stdout);" rngLn="157">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="163" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="163" locStartPos="8" locEndLn="163" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="164" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="164" locStartPos="8" locEndLn="164" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="164" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="164" locStartPos="8" locEndLn="164" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="164" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="164" locStartPos="8" locEndLn="164" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="164" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="164" locStartPos="8" locEndLn="164" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="164" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="323751784" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="164" locStartPos="0" locEndLn="165" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="164" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="165" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="155" srcRngStartPos="0" srcRngEndLn="156" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="155" ElType="." desc="if (current_vin[0] == '\0') {" rngLn="155">
          <Anns>
            <Ann msg="Condition evaluation: (current_vin[0] == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="161" srcRngStartPos="0" srcRngEndLn="162" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="161" ElType="." desc="IgnitionMap* map = find_map(map_id);" rngLn="161">
          <ElDescList>
            <ElDesc srcRngStartln="83" srcRngStartPos="0" srcRngEndLn="84" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="83" ElType="." desc="int i;" rngLn="83"/>
            <ElDesc srcRngStartln="84" srcRngStartPos="0" srcRngEndLn="85" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="84" ElType="." desc="for (i = 0; i &lt; MAX_MAPS; i++) {" rngLn="84">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt; 6) (assuming true)" kind="condEval"/>
                <Ann msg="Entering the loop" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="85" srcRngStartPos="0" srcRngEndLn="86" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="85" ElType="." desc="if (strcmp(maps[i].id, map_id) == 0) {" rngLn="85">
              <Anns>
                <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="84" srcRngStartPos="0" srcRngEndLn="85" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="84" ElType="." desc="for (i = 0; i &lt; MAX_MAPS; i++) {" rngLn="84">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt; 6) (assuming false)" kind="condEval"/>
                <Ann msg="Not entering the loop" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="89" srcRngStartPos="0" srcRngEndLn="90" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="89" ElType="." desc="return NULL;" rngLn="89"/>
          </ElDescList>
        </ElDesc>
        <ElDesc srcRngStartln="162" srcRngStartPos="0" srcRngEndLn="163" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="162" ElType="." desc="if (map == NULL) {" rngLn="162">
          <Anns>
            <Ann msg="Condition evaluation: (map == 0) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="163" srcRngStartPos="0" srcRngEndLn="164" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="163" ElType="." desc="printf(&quot;ERROR: Unknown map ID '%s'\n&quot;, map_id);" rngLn="163"/>
        <ElDesc srcRngStartln="164" srcRngStartPos="0" srcRngEndLn="165" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="164" ElType="CP" desc="fflush(stdout);" rngLn="164">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="177" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="177" locStartPos="4" locEndLn="177" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="178" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="178" locStartPos="4" locEndLn="178" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="178" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="178" locStartPos="4" locEndLn="178" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="178" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="178" locStartPos="4" locEndLn="178" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="178" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="178" locStartPos="4" locEndLn="178" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="178" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="38126695" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="178" locStartPos="0" locEndLn="179" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="178" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="179" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="155" srcRngStartPos="0" srcRngEndLn="156" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="155" ElType="." desc="if (current_vin[0] == '\0') {" rngLn="155">
          <Anns>
            <Ann msg="Condition evaluation: (current_vin[0] == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="161" srcRngStartPos="0" srcRngEndLn="162" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="161" ElType="." desc="IgnitionMap* map = find_map(map_id);" rngLn="161">
          <ElDescList>
            <ElDesc srcRngStartln="83" srcRngStartPos="0" srcRngEndLn="84" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="83" ElType="." desc="int i;" rngLn="83"/>
            <ElDesc srcRngStartln="84" srcRngStartPos="0" srcRngEndLn="85" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="84" ElType="." desc="for (i = 0; i &lt; MAX_MAPS; i++) {" rngLn="84">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt; 6) (assuming true)" kind="condEval"/>
                <Ann msg="Entering the loop" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="85" srcRngStartPos="0" srcRngEndLn="86" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="85" ElType="." desc="if (strcmp(maps[i].id, map_id) == 0) {" rngLn="85">
              <Anns>
                <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="86" srcRngStartPos="0" srcRngEndLn="87" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="86" ElType="." desc="return &amp;maps[i];" rngLn="86"/>
          </ElDescList>
        </ElDesc>
        <ElDesc srcRngStartln="162" srcRngStartPos="0" srcRngEndLn="163" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="162" ElType="." desc="if (map == NULL) {" rngLn="162">
          <Anns>
            <Ann msg="Condition evaluation: (map == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="168" srcRngStartPos="0" srcRngEndLn="169" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="168" ElType="." desc="VehicleInfo* vehicle = NULL;" rngLn="168"/>
        <ElDesc srcRngStartln="169" srcRngStartPos="0" srcRngEndLn="170" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="169" ElType="." desc="int i;" rngLn="169"/>
        <ElDesc srcRngStartln="170" srcRngStartPos="0" srcRngEndLn="171" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="170" ElType="." desc="for (i = 0; i &lt; MAX_VINS; i++) {" rngLn="170">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; 3) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="171" srcRngStartPos="0" srcRngEndLn="172" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="171" ElType="." desc="if (strcmp(vehicles[i].vin, current_vin) == 0) {" rngLn="171">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="172" srcRngStartPos="0" srcRngEndLn="173" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="172" ElType="." desc="vehicle = &amp;vehicles[i];" rngLn="172"/>
        <ElDesc srcRngStartln="173" srcRngStartPos="0" srcRngEndLn="174" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="173" ElType="." desc="break;" rngLn="173">
          <Anns>
            <Ann msg="Exit the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="177" srcRngStartPos="0" srcRngEndLn="178" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="177" ElType="." desc="printf(&quot;PROMPT: Re-enter VIN from motorcycle documents for verification:\n&quot;);" rngLn="177"/>
        <ElDesc srcRngStartln="178" srcRngStartPos="0" srcRngEndLn="179" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="178" ElType="CP" desc="fflush(stdout);" rngLn="178">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The 'scanf' library function should not be used" ln="180" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="180" locStartPos="4" locEndLn="180" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: %d" ln="180" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="180" locStartPos="10" locEndLn="180" locEndPos="11" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'scanf' should be used" ln="180" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="180" locStartPos="4" locEndLn="180" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'scanf' should be used" ln="180" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="180" locStartPos="4" locEndLn="180" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unsafe string function 'scanf' is being used" ln="180" sev="1" auth="danie" rule="CERT_C-STR07-a" tool="c++test" cat="CERT_C-STR07" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="180" locStartPos="4" locEndLn="180" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unsafe string function 'scanf' is being used" ln="180" sev="3" auth="danie" rule="CERT_C-INT05-a" tool="c++test" cat="CERT_C-INT05" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="180" locStartPos="4" locEndLn="180" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;scanf&quot; return value" ln="180" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="180" locStartPos="4" locEndLn="180" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;scanf&quot; should be checked" ln="180" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="-578301976" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="180" locStartPos="0" locEndLn="181" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="180" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="181" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="155" srcRngStartPos="0" srcRngEndLn="156" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="155" ElType="." desc="if (current_vin[0] == '\0') {" rngLn="155">
          <Anns>
            <Ann msg="Condition evaluation: (current_vin[0] == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="161" srcRngStartPos="0" srcRngEndLn="162" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="161" ElType="." desc="IgnitionMap* map = find_map(map_id);" rngLn="161">
          <ElDescList>
            <ElDesc srcRngStartln="83" srcRngStartPos="0" srcRngEndLn="84" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="83" ElType="." desc="int i;" rngLn="83"/>
            <ElDesc srcRngStartln="84" srcRngStartPos="0" srcRngEndLn="85" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="84" ElType="." desc="for (i = 0; i &lt; MAX_MAPS; i++) {" rngLn="84">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt; 6) (assuming true)" kind="condEval"/>
                <Ann msg="Entering the loop" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="85" srcRngStartPos="0" srcRngEndLn="86" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="85" ElType="." desc="if (strcmp(maps[i].id, map_id) == 0) {" rngLn="85">
              <Anns>
                <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="86" srcRngStartPos="0" srcRngEndLn="87" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="86" ElType="." desc="return &amp;maps[i];" rngLn="86"/>
          </ElDescList>
        </ElDesc>
        <ElDesc srcRngStartln="162" srcRngStartPos="0" srcRngEndLn="163" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="162" ElType="." desc="if (map == NULL) {" rngLn="162">
          <Anns>
            <Ann msg="Condition evaluation: (map == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="168" srcRngStartPos="0" srcRngEndLn="169" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="168" ElType="." desc="VehicleInfo* vehicle = NULL;" rngLn="168"/>
        <ElDesc srcRngStartln="169" srcRngStartPos="0" srcRngEndLn="170" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="169" ElType="." desc="int i;" rngLn="169"/>
        <ElDesc srcRngStartln="170" srcRngStartPos="0" srcRngEndLn="171" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="170" ElType="." desc="for (i = 0; i &lt; MAX_VINS; i++) {" rngLn="170">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; 3) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="171" srcRngStartPos="0" srcRngEndLn="172" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="171" ElType="." desc="if (strcmp(vehicles[i].vin, current_vin) == 0) {" rngLn="171">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="172" srcRngStartPos="0" srcRngEndLn="173" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="172" ElType="." desc="vehicle = &amp;vehicles[i];" rngLn="172"/>
        <ElDesc srcRngStartln="173" srcRngStartPos="0" srcRngEndLn="174" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="173" ElType="." desc="break;" rngLn="173">
          <Anns>
            <Ann msg="Exit the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="177" srcRngStartPos="0" srcRngEndLn="178" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="177" ElType="." desc="printf(&quot;PROMPT: Re-enter VIN from motorcycle documents for verification:\n&quot;);" rngLn="177"/>
        <ElDesc srcRngStartln="178" srcRngStartPos="0" srcRngEndLn="179" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="178" ElType="." desc="fflush(stdout);" rngLn="178"/>
        <ElDesc srcRngStartln="180" srcRngStartPos="0" srcRngEndLn="181" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="180" ElType="CP" desc="scanf(&quot;%d&quot;, &amp;vin_verification);" rngLn="180">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Declare local variable 'current_vin_num' as const" ln="182" sev="3" auth="danie" rule="CERT_C-DCL00-a" tool="c++test" cat="CERT_C-DCL00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="182" locStartPos="8" locEndLn="182" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Do not use the 'atoi' function" ln="182" sev="3" auth="danie" rule="CERT_C-ERR34-a" tool="c++test" cat="CERT_C-ERR34" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="182" locStartPos="26" locEndLn="182" locEndPos="27" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Do not use the 'atoi' function" ln="182" sev="3" auth="danie" rule="CERT_C-MSC24-a" tool="c++test" cat="CERT_C-MSC24" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="182" locStartPos="26" locEndLn="182" locEndPos="27" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Do not use the 'atoi' function" ln="182" sev="2" auth="danie" rule="CERT_C-ERR07-a" tool="c++test" cat="CERT_C-ERR07" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="182" locStartPos="26" locEndLn="182" locEndPos="27" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The right hand operand of the logical operator '&amp;&amp;' should have essentially Boolean type" ln="185" sev="2" auth="danie" rule="CERT_C-INT31-a" tool="c++test" cat="CERT_C-INT31" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="185" locStartPos="12" locEndLn="185" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Use parenthesis to clarify order ('==' is the first operand of '&amp;&amp;')" ln="185" sev="3" auth="danie" rule="CERT_C-EXP00-a" tool="c++test" cat="CERT_C-EXP00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="185" locStartPos="12" locEndLn="185" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="186" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="186" locStartPos="12" locEndLn="186" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="187" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="187" locStartPos="12" locEndLn="187" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="187" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="187" locStartPos="12" locEndLn="187" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="187" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="187" locStartPos="12" locEndLn="187" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="187" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="187" locStartPos="12" locEndLn="187" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="187" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="-1611310234" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="187" locStartPos="0" locEndLn="188" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="187" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="188" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="155" srcRngStartPos="0" srcRngEndLn="156" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="155" ElType="." desc="if (current_vin[0] == '\0') {" rngLn="155">
          <Anns>
            <Ann msg="Condition evaluation: (current_vin[0] == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="161" srcRngStartPos="0" srcRngEndLn="162" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="161" ElType="." desc="IgnitionMap* map = find_map(map_id);" rngLn="161">
          <ElDescList>
            <ElDesc srcRngStartln="83" srcRngStartPos="0" srcRngEndLn="84" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="83" ElType="." desc="int i;" rngLn="83"/>
            <ElDesc srcRngStartln="84" srcRngStartPos="0" srcRngEndLn="85" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="84" ElType="." desc="for (i = 0; i &lt; MAX_MAPS; i++) {" rngLn="84">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt; 6) (assuming true)" kind="condEval"/>
                <Ann msg="Entering the loop" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="85" srcRngStartPos="0" srcRngEndLn="86" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="85" ElType="." desc="if (strcmp(maps[i].id, map_id) == 0) {" rngLn="85">
              <Anns>
                <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="86" srcRngStartPos="0" srcRngEndLn="87" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="86" ElType="." desc="return &amp;maps[i];" rngLn="86"/>
          </ElDescList>
        </ElDesc>
        <ElDesc srcRngStartln="162" srcRngStartPos="0" srcRngEndLn="163" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="162" ElType="." desc="if (map == NULL) {" rngLn="162">
          <Anns>
            <Ann msg="Condition evaluation: (map == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="168" srcRngStartPos="0" srcRngEndLn="169" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="168" ElType="." desc="VehicleInfo* vehicle = NULL;" rngLn="168"/>
        <ElDesc srcRngStartln="169" srcRngStartPos="0" srcRngEndLn="170" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="169" ElType="." desc="int i;" rngLn="169"/>
        <ElDesc srcRngStartln="170" srcRngStartPos="0" srcRngEndLn="171" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="170" ElType="." desc="for (i = 0; i &lt; MAX_VINS; i++) {" rngLn="170">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; 3) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="171" srcRngStartPos="0" srcRngEndLn="172" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="171" ElType="." desc="if (strcmp(vehicles[i].vin, current_vin) == 0) {" rngLn="171">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="172" srcRngStartPos="0" srcRngEndLn="173" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="172" ElType="." desc="vehicle = &amp;vehicles[i];" rngLn="172"/>
        <ElDesc srcRngStartln="173" srcRngStartPos="0" srcRngEndLn="174" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="173" ElType="." desc="break;" rngLn="173">
          <Anns>
            <Ann msg="Exit the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="177" srcRngStartPos="0" srcRngEndLn="178" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="177" ElType="." desc="printf(&quot;PROMPT: Re-enter VIN from motorcycle documents for verification:\n&quot;);" rngLn="177"/>
        <ElDesc srcRngStartln="178" srcRngStartPos="0" srcRngEndLn="179" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="178" ElType="." desc="fflush(stdout);" rngLn="178"/>
        <ElDesc srcRngStartln="180" srcRngStartPos="0" srcRngEndLn="181" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="180" ElType="." desc="scanf(&quot;%d&quot;, &amp;vin_verification);" rngLn="180"/>
        <ElDesc srcRngStartln="182" srcRngStartPos="0" srcRngEndLn="183" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="182" ElType="." desc="int current_vin_num = atoi(current_vin);" rngLn="182"/>
        <ElDesc srcRngStartln="184" srcRngStartPos="0" srcRngEndLn="185" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="184" ElType="." desc="if (vin_verification == current_vin_num) {" rngLn="184">
          <Anns>
            <Ann msg="Condition evaluation: (vin_verification == current_vin_num) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="185" srcRngStartPos="0" srcRngEndLn="186" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="185" ElType="." desc="if (current_ecu_type == ECU_ROAD &amp;&amp; map->is_race_map) {" rngLn="185">
          <Anns>
            <Ann msg="Condition evaluation: (current_ecu_type == 0) (assuming true)" kind="condEval"/>
            <Ann msg="Condition evaluation: (map->is_race_map != 0) (assuming true)" kind="condEval"/>
            <Ann msg="Condition evaluation: current_ecu_type == ECU_ROAD &amp;&amp; map->is_race_map (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="186" srcRngStartPos="0" srcRngEndLn="187" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="186" ElType="." desc="printf(&quot;ERROR: Race maps not allowed on ROAD ECUs (regulatory violation)\n&quot;);" rngLn="186"/>
        <ElDesc srcRngStartln="187" srcRngStartPos="0" srcRngEndLn="188" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="187" ElType="CP" desc="fflush(stdout);" rngLn="187">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Do not use the literal constant '100000'" ln="190" sev="3" auth="danie" rule="CERT_C-DCL06-a" tool="c++test" cat="CERT_C-DCL06" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="190" locStartPos="35" locEndLn="190" locEndPos="36" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Do not use the literal constant '999999'" ln="190" sev="3" auth="danie" rule="CERT_C-DCL06-a" tool="c++test" cat="CERT_C-DCL06" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="190" locStartPos="65" locEndLn="190" locEndPos="66" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Provide 'else' after the last 'else-if' construct" ln="190" sev="2" auth="danie" rule="CERT_C-MSC01-a" tool="c++test" cat="CERT_C-MSC01" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="190" locStartPos="11" locEndLn="190" locEndPos="12" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Use parenthesis to clarify order ('&lt;=' is the second operand of '&amp;&amp;')" ln="190" sev="3" auth="danie" rule="CERT_C-EXP00-a" tool="c++test" cat="CERT_C-EXP00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="190" locStartPos="45" locEndLn="190" locEndPos="46" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Use parenthesis to clarify order ('>=' is the first operand of '&amp;&amp;')" ln="190" sev="3" auth="danie" rule="CERT_C-EXP00-a" tool="c++test" cat="CERT_C-EXP00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="190" locStartPos="15" locEndLn="190" locEndPos="16" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="191" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="191" locStartPos="8" locEndLn="191" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="192" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="192" locStartPos="8" locEndLn="192" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="192" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="192" locStartPos="8" locEndLn="192" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="192" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="192" locStartPos="8" locEndLn="192" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="192" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="192" locStartPos="8" locEndLn="192" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="192" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="-464573508" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="192" locStartPos="0" locEndLn="193" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="192" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="193" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="155" srcRngStartPos="0" srcRngEndLn="156" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="155" ElType="." desc="if (current_vin[0] == '\0') {" rngLn="155">
          <Anns>
            <Ann msg="Condition evaluation: (current_vin[0] == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="161" srcRngStartPos="0" srcRngEndLn="162" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="161" ElType="." desc="IgnitionMap* map = find_map(map_id);" rngLn="161">
          <ElDescList>
            <ElDesc srcRngStartln="83" srcRngStartPos="0" srcRngEndLn="84" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="83" ElType="." desc="int i;" rngLn="83"/>
            <ElDesc srcRngStartln="84" srcRngStartPos="0" srcRngEndLn="85" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="84" ElType="." desc="for (i = 0; i &lt; MAX_MAPS; i++) {" rngLn="84">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt; 6) (assuming true)" kind="condEval"/>
                <Ann msg="Entering the loop" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="85" srcRngStartPos="0" srcRngEndLn="86" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="85" ElType="." desc="if (strcmp(maps[i].id, map_id) == 0) {" rngLn="85">
              <Anns>
                <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="86" srcRngStartPos="0" srcRngEndLn="87" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="86" ElType="." desc="return &amp;maps[i];" rngLn="86"/>
          </ElDescList>
        </ElDesc>
        <ElDesc srcRngStartln="162" srcRngStartPos="0" srcRngEndLn="163" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="162" ElType="." desc="if (map == NULL) {" rngLn="162">
          <Anns>
            <Ann msg="Condition evaluation: (map == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="168" srcRngStartPos="0" srcRngEndLn="169" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="168" ElType="." desc="VehicleInfo* vehicle = NULL;" rngLn="168"/>
        <ElDesc srcRngStartln="169" srcRngStartPos="0" srcRngEndLn="170" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="169" ElType="." desc="int i;" rngLn="169"/>
        <ElDesc srcRngStartln="170" srcRngStartPos="0" srcRngEndLn="171" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="170" ElType="." desc="for (i = 0; i &lt; MAX_VINS; i++) {" rngLn="170">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; 3) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="171" srcRngStartPos="0" srcRngEndLn="172" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="171" ElType="." desc="if (strcmp(vehicles[i].vin, current_vin) == 0) {" rngLn="171">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="172" srcRngStartPos="0" srcRngEndLn="173" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="172" ElType="." desc="vehicle = &amp;vehicles[i];" rngLn="172"/>
        <ElDesc srcRngStartln="173" srcRngStartPos="0" srcRngEndLn="174" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="173" ElType="." desc="break;" rngLn="173">
          <Anns>
            <Ann msg="Exit the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="177" srcRngStartPos="0" srcRngEndLn="178" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="177" ElType="." desc="printf(&quot;PROMPT: Re-enter VIN from motorcycle documents for verification:\n&quot;);" rngLn="177"/>
        <ElDesc srcRngStartln="178" srcRngStartPos="0" srcRngEndLn="179" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="178" ElType="." desc="fflush(stdout);" rngLn="178"/>
        <ElDesc srcRngStartln="180" srcRngStartPos="0" srcRngEndLn="181" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="180" ElType="." desc="scanf(&quot;%d&quot;, &amp;vin_verification);" rngLn="180"/>
        <ElDesc srcRngStartln="182" srcRngStartPos="0" srcRngEndLn="183" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="182" ElType="." desc="int current_vin_num = atoi(current_vin);" rngLn="182"/>
        <ElDesc srcRngStartln="184" srcRngStartPos="0" srcRngEndLn="185" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="184" ElType="." desc="if (vin_verification == current_vin_num) {" rngLn="184">
          <Anns>
            <Ann msg="Condition evaluation: (vin_verification == current_vin_num) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="190" srcRngStartPos="0" srcRngEndLn="191" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="190" ElType="." desc="} else if (vin_verification >= 100000 &amp;&amp; vin_verification &lt;= 999999) {" rngLn="190">
          <Anns>
            <Ann msg="Condition evaluation: (vin_verification >= 100000) (assuming true)" kind="condEval"/>
            <Ann msg="Condition evaluation: (vin_verification &lt;= 999999) (assuming true)" kind="condEval"/>
            <Ann msg="Condition evaluation: vin_verification >= 100000 &amp;&amp; vin_verification &lt;= 999999 (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="191" srcRngStartPos="0" srcRngEndLn="192" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="191" ElType="." desc="printf(&quot;ERROR: VIN mismatch. Please try again.\n&quot;);" rngLn="191"/>
        <ElDesc srcRngStartln="192" srcRngStartPos="0" srcRngEndLn="193" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="192" ElType="CP" desc="fflush(stdout);" rngLn="192">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The operand of the logical negation operator '!' should have essentially Boolean type" ln="196" sev="2" auth="danie" rule="CERT_C-INT31-a" tool="c++test" cat="CERT_C-INT31" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="196" locStartPos="8" locEndLn="196" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="197" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="197" locStartPos="8" locEndLn="197" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="200" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="200" locStartPos="4" locEndLn="200" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="202" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="202" locStartPos="4" locEndLn="202" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="202" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="202" locStartPos="4" locEndLn="202" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="202" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="202" locStartPos="4" locEndLn="202" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="202" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="202" locStartPos="4" locEndLn="202" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="202" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="-1568015931" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="202" locStartPos="0" locEndLn="203" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="202" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="203" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="155" srcRngStartPos="0" srcRngEndLn="156" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="155" ElType="." desc="if (current_vin[0] == '\0') {" rngLn="155">
          <Anns>
            <Ann msg="Condition evaluation: (current_vin[0] == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="161" srcRngStartPos="0" srcRngEndLn="162" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="161" ElType="." desc="IgnitionMap* map = find_map(map_id);" rngLn="161">
          <ElDescList>
            <ElDesc srcRngStartln="83" srcRngStartPos="0" srcRngEndLn="84" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="83" ElType="." desc="int i;" rngLn="83"/>
            <ElDesc srcRngStartln="84" srcRngStartPos="0" srcRngEndLn="85" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="84" ElType="." desc="for (i = 0; i &lt; MAX_MAPS; i++) {" rngLn="84">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt; 6) (assuming true)" kind="condEval"/>
                <Ann msg="Entering the loop" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="85" srcRngStartPos="0" srcRngEndLn="86" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="85" ElType="." desc="if (strcmp(maps[i].id, map_id) == 0) {" rngLn="85">
              <Anns>
                <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="86" srcRngStartPos="0" srcRngEndLn="87" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="86" ElType="." desc="return &amp;maps[i];" rngLn="86"/>
          </ElDescList>
        </ElDesc>
        <ElDesc srcRngStartln="162" srcRngStartPos="0" srcRngEndLn="163" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="162" ElType="." desc="if (map == NULL) {" rngLn="162">
          <Anns>
            <Ann msg="Condition evaluation: (map == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="168" srcRngStartPos="0" srcRngEndLn="169" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="168" ElType="." desc="VehicleInfo* vehicle = NULL;" rngLn="168"/>
        <ElDesc srcRngStartln="169" srcRngStartPos="0" srcRngEndLn="170" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="169" ElType="." desc="int i;" rngLn="169"/>
        <ElDesc srcRngStartln="170" srcRngStartPos="0" srcRngEndLn="171" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="170" ElType="." desc="for (i = 0; i &lt; MAX_VINS; i++) {" rngLn="170">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; 3) (assuming true)" kind="condEval"/>
            <Ann msg="Entering the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="171" srcRngStartPos="0" srcRngEndLn="172" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="171" ElType="." desc="if (strcmp(vehicles[i].vin, current_vin) == 0) {" rngLn="171">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="172" srcRngStartPos="0" srcRngEndLn="173" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="172" ElType="." desc="vehicle = &amp;vehicles[i];" rngLn="172"/>
        <ElDesc srcRngStartln="173" srcRngStartPos="0" srcRngEndLn="174" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="173" ElType="." desc="break;" rngLn="173">
          <Anns>
            <Ann msg="Exit the loop" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="177" srcRngStartPos="0" srcRngEndLn="178" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="177" ElType="." desc="printf(&quot;PROMPT: Re-enter VIN from motorcycle documents for verification:\n&quot;);" rngLn="177"/>
        <ElDesc srcRngStartln="178" srcRngStartPos="0" srcRngEndLn="179" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="178" ElType="." desc="fflush(stdout);" rngLn="178"/>
        <ElDesc srcRngStartln="180" srcRngStartPos="0" srcRngEndLn="181" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="180" ElType="." desc="scanf(&quot;%d&quot;, &amp;vin_verification);" rngLn="180"/>
        <ElDesc srcRngStartln="182" srcRngStartPos="0" srcRngEndLn="183" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="182" ElType="." desc="int current_vin_num = atoi(current_vin);" rngLn="182"/>
        <ElDesc srcRngStartln="184" srcRngStartPos="0" srcRngEndLn="185" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="184" ElType="." desc="if (vin_verification == current_vin_num) {" rngLn="184">
          <Anns>
            <Ann msg="Condition evaluation: (vin_verification == current_vin_num) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="185" srcRngStartPos="0" srcRngEndLn="186" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="185" ElType="." desc="if (current_ecu_type == ECU_ROAD &amp;&amp; map->is_race_map) {" rngLn="185">
          <Anns>
            <Ann msg="Condition evaluation: (current_ecu_type == 0) (assuming false)" kind="condEval"/>
            <Ann msg="Condition evaluation: current_ecu_type == ECU_ROAD &amp;&amp; map->is_race_map (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="196" srcRngStartPos="0" srcRngEndLn="197" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="196" ElType="." desc="is_map_allowed_for_vin(...)" rngLn="196">
          <ElDescList>
            <ElDesc srcRngStartln="93" srcRngStartPos="0" srcRngEndLn="94" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="93" ElType="." desc="int i;" rngLn="93"/>
            <ElDesc srcRngStartln="94" srcRngStartPos="0" srcRngEndLn="95" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="94" ElType="." desc="for (i = 0; i &lt; vehicle->num_allowed_maps; i++) {" rngLn="94">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt; vehicle->num_allowed_maps) (assuming false)" kind="condEval"/>
                <Ann msg="Not entering the loop" kind="condEval"/>
              </Anns>
            </ElDesc>
            <ElDesc srcRngStartln="99" srcRngStartPos="0" srcRngEndLn="100" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="99" ElType="." desc="return 0;" rngLn="99"/>
          </ElDescList>
        </ElDesc>
        <ElDesc srcRngStartln="196" srcRngStartPos="0" srcRngEndLn="197" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="196" ElType="." desc="if (!is_map_allowed_for_vin(map_id, vehicle)) {" rngLn="196">
          <Anns>
            <Ann msg="Condition evaluation: !is_map_allowed_for_vin(map_id, vehicle) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="197" srcRngStartPos="0" srcRngEndLn="198" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="197" ElType="." desc="printf(&quot;WARNING: Map not in standard allowed list for this VIN\n&quot;);" rngLn="197"/>
        <ElDesc srcRngStartln="200" srcRngStartPos="0" srcRngEndLn="201" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="200" ElType="." desc="printf(&quot;SUCCESS: Map '%s' (%s, %dHP) flashed to VIN %s\n&quot;," rngLn="200"/>
        <ElDesc srcRngStartln="202" srcRngStartPos="0" srcRngEndLn="203" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="202" ElType="CP" desc="fflush(stdout);" rngLn="202">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Declare parameter 'command' as const" ln="205" sev="3" auth="danie" rule="CERT_C-DCL00-b" tool="c++test" cat="CERT_C-DCL00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="205" locStartPos="27" locEndLn="205" locEndPos="28" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Function 'process_command' has external linkage and is not declared in the header" ln="205" sev="3" auth="danie" rule="CERT_C-DCL15-a" tool="c++test" cat="CERT_C-DCL15" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="205" locStartPos="5" locEndLn="205" locEndPos="6" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Parameter 'command' is not validated before use" ln="205" sev="3" auth="danie" rule="CERT_C-API00-a" tool="c++test" cat="CERT_C-API00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="205" locStartPos="27" locEndLn="205" locEndPos="28" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Pass parameter &quot;command&quot; with const specifier" ln="205" sev="3" auth="danie" rule="CERT_C-DCL13-a" tool="c++test" cat="CERT_C-DCL13" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="205" locStartPos="27" locEndLn="205" locEndPos="28" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Declare local variable 'num_tokens' as const" ln="209" sev="3" auth="danie" rule="CERT_C-DCL00-a" tool="c++test" cat="CERT_C-DCL00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="209" locStartPos="8" locEndLn="209" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'sscanf' library function should not be used" ln="209" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="209" locStartPos="21" locEndLn="209" locEndPos="22" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: %s %s" ln="209" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="209" locStartPos="37" locEndLn="209" locEndPos="38" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unsafe string function 'sscanf' is being used" ln="209" sev="1" auth="danie" rule="CERT_C-STR07-a" tool="c++test" cat="CERT_C-STR07" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="209" locStartPos="21" locEndLn="209" locEndPos="22" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unsafe string function 'sscanf' is being used" ln="209" sev="3" auth="danie" rule="CERT_C-INT05-a" tool="c++test" cat="CERT_C-INT05" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="209" locStartPos="21" locEndLn="209" locEndPos="22" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: IDENTIFY" ln="211" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="211" locStartPos="20" locEndLn="211" locEndPos="21" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Prototype of function 'cmd_identify' does not precede function call" ln="212" sev="3" auth="danie" rule="CERT_C-EXP37-d" tool="c++test" cat="CERT_C-EXP37" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="212" locStartPos="8" locEndLn="212" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: GET_ALLOWED_MAPS" ln="213" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="213" locStartPos="27" locEndLn="213" locEndPos="28" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Prototype of function 'cmd_get_allowed_maps' does not precede function call" ln="214" sev="3" auth="danie" rule="CERT_C-EXP37-d" tool="c++test" cat="CERT_C-EXP37" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="214" locStartPos="8" locEndLn="214" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The string literal is embedded directly in the code: FLASH_MAP" ln="215" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="215" locStartPos="27" locEndLn="215" locEndPos="28" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Do not use the literal constant '2'" ln="216" sev="3" auth="danie" rule="CERT_C-DCL06-a" tool="c++test" cat="CERT_C-DCL06" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="216" locStartPos="25" locEndLn="216" locEndPos="26" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="217" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="217" locStartPos="12" locEndLn="217" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="218" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="218" locStartPos="12" locEndLn="218" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="218" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="218" locStartPos="12" locEndLn="218" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="218" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="218" locStartPos="12" locEndLn="218" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="218" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="218" locStartPos="12" locEndLn="218" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="218" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="-82450253" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="218" locStartPos="0" locEndLn="219" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="218" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="219" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="206" srcRngStartPos="0" srcRngEndLn="207" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="206" ElType="." desc="char cmd[MAX_COMMAND_LEN];" rngLn="206"/>
        <ElDesc srcRngStartln="207" srcRngStartPos="0" srcRngEndLn="208" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="207" ElType="." desc="char arg[MAX_COMMAND_LEN];" rngLn="207"/>
        <ElDesc srcRngStartln="209" srcRngStartPos="0" srcRngEndLn="210" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="209" ElType="." desc="int num_tokens = sscanf(command, &quot;%s %s&quot;, cmd, arg);" rngLn="209"/>
        <ElDesc srcRngStartln="211" srcRngStartPos="0" srcRngEndLn="212" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="211" ElType="." desc="if (strcmp(cmd, &quot;IDENTIFY&quot;) == 0) {" rngLn="211">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="213" srcRngStartPos="0" srcRngEndLn="214" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="213" ElType="." desc="} else if (strcmp(cmd, &quot;GET_ALLOWED_MAPS&quot;) == 0) {" rngLn="213">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="215" srcRngStartPos="0" srcRngEndLn="216" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="215" ElType="." desc="} else if (strcmp(cmd, &quot;FLASH_MAP&quot;) == 0) {" rngLn="215">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="216" srcRngStartPos="0" srcRngEndLn="217" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="216" ElType="." desc="if (num_tokens &lt; 2) {" rngLn="216">
          <Anns>
            <Ann msg="Condition evaluation: (num_tokens &lt; 2) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="217" srcRngStartPos="0" srcRngEndLn="218" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="217" ElType="." desc="printf(&quot;ERROR: FLASH_MAP requires map_id argument\n&quot;);" rngLn="217"/>
        <ElDesc srcRngStartln="218" srcRngStartPos="0" srcRngEndLn="219" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="218" ElType="CP" desc="fflush(stdout);" rngLn="218">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The string literal is embedded directly in the code: QUIT" ln="222" sev="1" auth="danie" rule="CERT_C-MSC41-a" tool="c++test" cat="CERT_C-MSC41" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="222" locStartPos="27" locEndLn="222" locEndPos="28" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="223" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="223" locStartPos="8" locEndLn="223" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="224" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="224" locStartPos="8" locEndLn="224" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="224" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="224" locStartPos="8" locEndLn="224" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="224" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="224" locStartPos="8" locEndLn="224" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="224" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="224" locStartPos="8" locEndLn="224" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="224" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="-472248428" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="224" locStartPos="0" locEndLn="225" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="224" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="225" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="206" srcRngStartPos="0" srcRngEndLn="207" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="206" ElType="." desc="char cmd[MAX_COMMAND_LEN];" rngLn="206"/>
        <ElDesc srcRngStartln="207" srcRngStartPos="0" srcRngEndLn="208" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="207" ElType="." desc="char arg[MAX_COMMAND_LEN];" rngLn="207"/>
        <ElDesc srcRngStartln="209" srcRngStartPos="0" srcRngEndLn="210" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="209" ElType="." desc="int num_tokens = sscanf(command, &quot;%s %s&quot;, cmd, arg);" rngLn="209"/>
        <ElDesc srcRngStartln="211" srcRngStartPos="0" srcRngEndLn="212" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="211" ElType="." desc="if (strcmp(cmd, &quot;IDENTIFY&quot;) == 0) {" rngLn="211">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="213" srcRngStartPos="0" srcRngEndLn="214" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="213" ElType="." desc="} else if (strcmp(cmd, &quot;GET_ALLOWED_MAPS&quot;) == 0) {" rngLn="213">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="215" srcRngStartPos="0" srcRngEndLn="216" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="215" ElType="." desc="} else if (strcmp(cmd, &quot;FLASH_MAP&quot;) == 0) {" rngLn="215">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="222" srcRngStartPos="0" srcRngEndLn="223" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="222" ElType="." desc="} else if (strcmp(cmd, &quot;QUIT&quot;) == 0) {" rngLn="222">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming true)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="223" srcRngStartPos="0" srcRngEndLn="224" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="223" ElType="." desc="printf(&quot;QUIT_ACK\n&quot;);" rngLn="223"/>
        <ElDesc srcRngStartln="224" srcRngStartPos="0" srcRngEndLn="225" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="224" ElType="CP" desc="fflush(stdout);" rngLn="224">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The 'exit' library function should not be used" ln="225" sev="3" auth="danie" rule="CERT_C-ERR05-b" tool="c++test" cat="CERT_C-ERR05" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="225" locStartPos="8" locEndLn="225" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'exit' library function should not be used" ln="225" sev="3" auth="danie" rule="CERT_C-ERR04-b" tool="c++test" cat="CERT_C-ERR04" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="225" locStartPos="8" locEndLn="225" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="227" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="227" locStartPos="8" locEndLn="227" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="228" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="228" locStartPos="8" locEndLn="228" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="228" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="228" locStartPos="8" locEndLn="228" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="228" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="228" locStartPos="8" locEndLn="228" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="228" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="228" locStartPos="8" locEndLn="228" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="228" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="294085482" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="228" locStartPos="0" locEndLn="229" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="228" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="229" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="206" srcRngStartPos="0" srcRngEndLn="207" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="206" ElType="." desc="char cmd[MAX_COMMAND_LEN];" rngLn="206"/>
        <ElDesc srcRngStartln="207" srcRngStartPos="0" srcRngEndLn="208" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="207" ElType="." desc="char arg[MAX_COMMAND_LEN];" rngLn="207"/>
        <ElDesc srcRngStartln="209" srcRngStartPos="0" srcRngEndLn="210" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="209" ElType="." desc="int num_tokens = sscanf(command, &quot;%s %s&quot;, cmd, arg);" rngLn="209"/>
        <ElDesc srcRngStartln="211" srcRngStartPos="0" srcRngEndLn="212" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="211" ElType="." desc="if (strcmp(cmd, &quot;IDENTIFY&quot;) == 0) {" rngLn="211">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="213" srcRngStartPos="0" srcRngEndLn="214" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="213" ElType="." desc="} else if (strcmp(cmd, &quot;GET_ALLOWED_MAPS&quot;) == 0) {" rngLn="213">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="215" srcRngStartPos="0" srcRngEndLn="216" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="215" ElType="." desc="} else if (strcmp(cmd, &quot;FLASH_MAP&quot;) == 0) {" rngLn="215">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="222" srcRngStartPos="0" srcRngEndLn="223" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="222" ElType="." desc="} else if (strcmp(cmd, &quot;QUIT&quot;) == 0) {" rngLn="222">
          <Anns>
            <Ann msg="Condition evaluation: (strcmp(...) == 0) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc srcRngStartln="227" srcRngStartPos="0" srcRngEndLn="228" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="227" ElType="." desc="printf(&quot;ERROR: Unknown command '%s'\n&quot;, cmd);" rngLn="227"/>
        <ElDesc srcRngStartln="228" srcRngStartPos="0" srcRngEndLn="229" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="228" ElType="CP" desc="fflush(stdout);" rngLn="228">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Prototype of function 'init_system' does not precede function call" ln="235" sev="3" auth="danie" rule="CERT_C-EXP37-d" tool="c++test" cat="CERT_C-EXP37" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="235" locStartPos="4" locEndLn="235" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="237" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="237" locStartPos="4" locEndLn="237" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The 'fflush' library function should not be used" ln="238" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="238" locStartPos="4" locEndLn="238" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the POSIX library function 'fflush' should be used" ln="238" sev="1" auth="danie" rule="CERT_C-POS54-a" tool="c++test" cat="CERT_C-POS54" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="238" locStartPos="4" locEndLn="238" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The value returned by the standard library function 'fflush' should be used" ln="238" sev="1" auth="danie" rule="CERT_C-ERR33-a" tool="c++test" cat="CERT_C-ERR33" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="238" locStartPos="4" locEndLn="238" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unused function's &quot;fflush&quot; return value" ln="238" sev="3" auth="danie" rule="CERT_C-EXP12-a" tool="c++test" cat="CERT_C-EXP12" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="238" locStartPos="4" locEndLn="238" locEndPos="5" locFile="/ecu_simulator/ecu_sim.c"/>
    <FlowViol msg="Value returned from method &quot;fflush&quot; should be checked" ln="238" ruleSAFMsg="Point by which returned value should be checked" auth="danie" sev="1" rule="CERT_C-ERR33-d" ruleSCSCMsg="Method call" tool="c++test" id="224280814" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="238" locStartPos="0" locEndLn="239" locEndPos="0" locFile="/ecu_simulator/ecu_sim.c" FirstElSrcRngStartln="238" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="239" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/ecu_simulator/ecu_sim.c">
      <ElDescList>
        <ElDesc srcRngStartln="233" srcRngStartPos="0" srcRngEndLn="234" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="233" ElType="." desc="char command[MAX_COMMAND_LEN];" rngLn="233"/>
        <ElDesc srcRngStartln="235" srcRngStartPos="0" srcRngEndLn="236" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="235" ElType="." desc="init_system();" rngLn="235">
          <ElDescList>
            <ElDesc srcRngStartln="78" srcRngStartPos="0" srcRngEndLn="79" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="78" ElType="." desc="srand(time(NULL));" rngLn="78"/>
            <ElDesc srcRngStartln="79" srcRngStartPos="0" srcRngEndLn="80" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="79" ElType="." desc="current_vin[0] = '\0';" rngLn="79"/>
          </ElDescList>
        </ElDesc>
        <ElDesc srcRngStartln="237" srcRngStartPos="0" srcRngEndLn="238" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="237" ElType="." desc="printf(&quot;ECU_SIM_READY\n&quot;);" rngLn="237"/>
        <ElDesc srcRngStartln="238" srcRngStartPos="0" srcRngEndLn="239" srcRngEndPos="0" srcRngFile="/ecu_simulator/ecu_sim.c" srcRnghash="1145304834" ln="238" ElType="CP" desc="fflush(stdout);" rngLn="238">
          <Anns>
            <Ann msg="Method call" kind="cause"/>
            <Ann msg="Point by which returned value should be checked" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The 'fgets' library function should not be used" ln="241" sev="3" auth="danie" rule="CERT_C-ERR02-a" tool="c++test" cat="CERT_C-ERR02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="241" locStartPos="12" locEndLn="241" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The argument number '2' ('essentially unsigned' type) is passed to the function 'fgets' as a parameter with the 'essentially signed' type" ln="241" sev="2" auth="danie" rule="CERT_C-INT31-i" tool="c++test" cat="CERT_C-INT31" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="241" locStartPos="27" locEndLn="241" locEndPos="28" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unsafe functions 'fgets' is being used" ln="241" sev="3" auth="danie" rule="CERT_C-MSC24-d" tool="c++test" cat="CERT_C-MSC24" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="241" locStartPos="12" locEndLn="241" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unsafe functions 'fgets' is being used" ln="241" sev="1" auth="danie" rule="CERT_C-ENV01-a" tool="c++test" cat="CERT_C-ENV01" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="241" locStartPos="12" locEndLn="241" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Unsafe functions 'fgets' is being used" ln="241" sev="2" auth="danie" rule="CERT_C-API02-b" tool="c++test" cat="CERT_C-API02" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="241" locStartPos="12" locEndLn="241" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="The expression of the 'essentially signed' type is assigned to an object with the 'essentially character' type" ln="245" sev="2" auth="danie" rule="CERT_C-INT31-i" tool="c++test" cat="CERT_C-INT31" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="245" locStartPos="8" locEndLn="245" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="To the plain char type assign only character values" ln="245" sev="2" auth="danie" rule="CERT_C-INT07-a" tool="c++test" cat="CERT_C-INT07" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="245" locStartPos="8" locEndLn="245" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="To the plain char type assign only character values" ln="245" sev="1" auth="danie" rule="CERT_C-STR00-a" tool="c++test" cat="CERT_C-STR00" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="245" locStartPos="8" locEndLn="245" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="To the plain char type assign only character values" ln="245" sev="3" auth="danie" rule="CERT_C-STR04-a" tool="c++test" cat="CERT_C-STR04" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="245" locStartPos="8" locEndLn="245" locEndPos="9" locFile="/ecu_simulator/ecu_sim.c"/>
    <StdViol msg="Operands of the '>' operator have different essential types: 'unsigned int' and 'signed char'" ln="247" sev="2" auth="danie" rule="CERT_C-INT31-j" tool="c++test" cat="CERT_C-INT31" lang="cpp" locType="sr" config="1" hash="1145304834" locStartln="247" locStartPos="12" locEndLn="247" locEndPos="13" locFile="/ecu_simulator/ecu_sim.c"/>
  </StdViols>

      <Supps/>
      
   </CodingStandards>
   <AssocUrls/>
</ResultsSession>